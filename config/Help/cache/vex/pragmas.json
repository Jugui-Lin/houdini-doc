{"type": "root", "attrs": {"tags": "vcc"}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["VEX compiler pragmas"], "extent": [0, 25]}, {"type": "para", "indent": 0, "text": ["The ", {"scheme": null, "value": "vcc", "type": "link", "text": ["VEX compiler (vcc)"], "fullpath": "/vex/vcc"}, " supports pragmas for automatically building UI\ndialog scripts. These pragmas are typically ignored unless the -u option\nis specified on the vcc command line. The pragmas let you specify\nhelp, hints for how to represent the parameter, organization, and other\ninformation."], "extent": [38, 339]}, {"type": "para", "indent": 0, "text": ["Pragmas can be specified in one of two ways: As a ", {"type": "code", "text": ["#pragma"]}, " preprocessor \ndirective, or as a ", {"type": "code", "text": ["_Pragma"]}, " VEX statement. The second form allows for\nbundling up multiple pragmas in a single macro. "], "extent": [339, 534]}, {"type": "para", "indent": 0, "text": ["The following preprocessor form:"], "extent": [534, 568]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n#pragma label parm \"Parameter Label\"\n"], "extent": [568, 619]}, {"type": "para", "indent": 0, "text": ["is functionally equivalent to this VEX statement:"], "extent": [619, 671]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n_Pragma(\"label parm \\\"Parameter Label\\\"\");\n"], "extent": [671, 728]}, {"type": "para", "indent": 0, "text": ["Note that the pragma arguments are enclosed in quotes, with the original set\nof quotes escaped."], "extent": [728, 826]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma c++rawstring"], "extent": [826, 853], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma c++rawstring 0|1"]}], "extent": [853, 881]}, {"type": "para", "indent": 0, "text": ["VEX supports C++ style raw strings.  The ", {"type": "code", "text": ["c++rawstring"]}, " pragma can be used to\ndisable or re-enable raw string support.  For example:"], "extent": [881, 1014]}, {"lang": null, "type": "pre", "indent": 0, "text": ["\nstring a = R\"(Hello world\\n)\";\nstring b = \"Hello world\\\\n\";\n#pragma c++rawstrings 0        // Disable C++ style raw string support\nstring b = R\"(This will generate an error!)\";\n#pragma c++rawstrings 1        // Re-enable C++ style raw string support\n"], "extent": [1014, 1272]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma bindhandle"], "extent": [1272, 1298], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma bindhandle ", {"type": "var", "text": ["channel_name"]}, " ", {"type": "var", "text": ["h_name"]}, " ", {"type": "var", "text": ["h_label"]}, " ", {"type": "var", "text": ["h_index"]}, " ", {"type": "var", "text": ["h_settings"]}]}], "extent": [1298, 1388]}, {"type": "para", "indent": 0, "text": ["Binds handles to specific parameters by default (users can override\nbindings)."], "extent": [1388, 1468]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": [{"type": "code", "text": [" ", {"type": "var", "text": ["channel_name"]}, " "]}, " "], "extent": [1468, 1491], "body": [{"type": "para", "indent": 4, "text": ["The name of the channel in the VEX operator to bind to the handle."], "extent": [1491, 1562]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": [" ", {"type": "var", "text": ["h_name"]}, " "]}, " "], "extent": [1562, 1579], "body": [{"type": "para", "indent": 4, "text": ["Handle name. This is one of the pre-defined Houdini handles (for\n    example ", {"type": "code", "text": ["ladder"]}, "). You can use the ", {"scheme": "Cmd", "value": "/commands/omls", "type": "link", "text": ["omls"], "fallback_text": "omls", "fullpath": "/commands/omls"}, " HScript command\n    for a full list of available handles."], "extent": [1579, 1761]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": [" ", {"type": "var", "text": ["h_label"]}, " "]}, " "], "extent": [1761, 1779], "body": [{"type": "para", "indent": 4, "text": ["A brief description of the handle."], "extent": [1779, 1818]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": [" ", {"type": "var", "text": ["h_index"]}, " "]}, " "], "extent": [1818, 1836], "body": [{"type": "para", "indent": 4, "text": ["Many handles (for example xform) have multiple parameters associated\n    with them. This allows you to choose which handle parameter gets\n    bound to the VEX parameter."], "extent": [1836, 2010]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": [" ", {"type": "var", "text": ["h_settings"]}, " "]}, " "], "extent": [2010, 2031], "body": [{"type": "para", "indent": 4, "text": ["An optional handle-specific string that can be used to set some\n    default behavior for the handle."], "extent": [2031, 2137]}], "container": true}], "container": true}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n#pragma bindhandle offset1 xform \"Translate\" tx \"invisible(1)\"\n#pragma bindhandle offset2 xform \"Translate\" ty\n#pragma bindhandle offset3 xform \"Translate\" tz\nsop translate(vector offset=0) { P += offset; }\n"], "extent": [2137, 2358]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma bindhandlereserved"], "extent": [2358, 2392], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": [" #pragma bindhandlereserved ", {"type": "var", "text": ["reserved_channel_name"]}, " ", {"type": "var", "text": ["h_name"]}, "\n", {"type": "var", "text": ["h_label"]}, " ", {"type": "var", "text": ["h_index"]}, " ", {"type": "var", "text": ["h_settings"]}, " "]}], "extent": [2392, 2501]}, {"type": "para", "indent": 0, "text": ["Each scripted operator type has a number of parameters that are added to\nevery operator of that type (regardless of the contents of the dialog\nscript file). To bind a handle to one of these parameters, you must use\nthe bindhandlereserved pragma. This pragma takes exactly the same\narguments as the bindhandle pragma. The only exception is that the\nchannel name argument must specify the name of a reserved parameter."], "extent": [2501, 2919]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma bindselector"], "extent": [2919, 2946], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": [" #pragma bindselector [", {"type": "var", "text": ["parm_name"]}, "] ", {"type": "var", "text": ["sel_type"]}, " ", {"type": "var", "text": ["sel_name"]}, "\n", {"type": "var", "text": ["sel_prompt"]}, " ", {"type": "var", "text": ["sel_mask"]}, " ", {"type": "var", "text": ["allow_dragging"]}, " ", {"type": "var", "text": ["group_type_parm"]}, "\n", {"type": "var", "text": ["asterisk_sel_all"]}, " [", {"type": "var", "text": ["input_index"]}, " ", {"type": "var", "text": ["input_required"]}, "] "]}], "extent": [2946, 3140]}, {"type": "para", "indent": 0, "text": ["When an operator is created interactively in Houdini, the user can be\nprompted for the data to work on. These prompts are handled by\nselectors. Selectors can be defined on a per-OP basis, or a\nper-parameter basis."], "extent": [3140, 3355]}, {"type": "para", "indent": 0, "text": ["For per-OP selectors, the bindselector pragma expects 7 arguments. For\nper-parameter selectors, it expects 10 arguments."], "extent": [3355, 3477]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": [{"type": "var", "text": ["parm_name"]}, " "], "extent": [3477, 3493], "body": [{"type": "para", "indent": 4, "text": ["The VEX parameter to bind the selector to (for per-parameter\n    selectors)."], "extent": [3493, 3574]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "var", "text": ["sel_type"]}, " "], "extent": [3574, 3589], "body": [{"type": "para", "indent": 4, "text": ["The entity to select. Use the ", {"scheme": "Cmd", "value": "/commands/omsls", "type": "link", "text": ["omsls"], "fallback_text": "omsls", "fullpath": "/commands/omsls"}, " HScript command to\n    print a list of possible values."], "extent": [3589, 3697]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "var", "text": ["sel_name"]}, " "], "extent": [3697, 3712], "body": [{"type": "para", "indent": 4, "text": ["A brief description of the selector."], "extent": [3712, 3753]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "var", "text": ["sel_prompt"]}, " "], "extent": [3753, 3770], "body": [{"type": "para", "indent": 4, "text": ["the prompt presented to the user to select geometry."], "extent": [3770, 3827]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "var", "text": ["sel_mask"]}, " "], "extent": [3827, 3842], "body": [{"type": "para", "indent": 4, "text": ["a pattern which allows selection of specific primitive types. The\n    list of possible primitive types are:"], "extent": [3842, 3955]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["all"], "extent": [3955, 3964], "body": [{"type": "para", "indent": 8, "text": ["all primitive types"], "extent": [3964, 3992]}], "container": true}, {"type": "dt", "indent": 4, "text": ["face"], "extent": [3992, 4002], "body": [{"type": "para", "indent": 8, "text": ["Polygons, NURBs or Bezier curves."], "extent": [4002, 4044]}], "container": true}, {"type": "dt", "indent": 4, "text": ["surface"], "extent": [4044, 4057], "body": [{"type": "para", "indent": 8, "text": ["Mesh, NURBs or Bezier surfaces"], "extent": [4057, 4096]}], "container": true}, {"type": "dt", "indent": 4, "text": ["quadric"], "extent": [4096, 4109], "body": [{"type": "para", "indent": 8, "text": ["Primitive circles, spheres or tubes."], "extent": [4109, 4154]}], "container": true}, {"type": "dt", "indent": 4, "text": ["poly"], "extent": [4154, 4164], "body": [{"type": "para", "indent": 8, "text": ["Polygons"], "extent": [4164, 4181]}], "container": true}, {"type": "dt", "indent": 4, "text": ["nurbscurve"], "extent": [4181, 4197], "body": [{"type": "para", "indent": 8, "text": ["NURBS curves"], "extent": [4197, 4218]}], "container": true}, {"type": "dt", "indent": 4, "text": ["bezcurve"], "extent": [4218, 4232], "body": [{"type": "para", "indent": 8, "text": ["Bezier curves"], "extent": [4232, 4254]}], "container": true}, {"type": "dt", "indent": 4, "text": ["mesh"], "extent": [4254, 4264], "body": [{"type": "para", "indent": 8, "text": ["Meshes"], "extent": [4264, 4279]}], "container": true}, {"type": "dt", "indent": 4, "text": ["nurbs"], "extent": [4279, 4290], "body": [{"type": "para", "indent": 8, "text": ["NURBS surfaces"], "extent": [4290, 4313]}], "container": true}, {"type": "dt", "indent": 4, "text": ["bezier"], "extent": [4313, 4325], "body": [{"type": "para", "indent": 8, "text": ["Bezier surfaces"], "extent": [4325, 4349]}], "container": true}, {"type": "dt", "indent": 4, "text": ["circle"], "extent": [4349, 4361], "body": [{"type": "para", "indent": 8, "text": ["Primitive circles"], "extent": [4361, 4387]}], "container": true}, {"type": "dt", "indent": 4, "text": ["sphere"], "extent": [4387, 4399], "body": [{"type": "para", "indent": 8, "text": ["Primitive spheres"], "extent": [4399, 4425]}], "container": true}, {"type": "dt", "indent": 4, "text": ["tube"], "extent": [4425, 4435], "body": [{"type": "para", "indent": 8, "text": ["Primitive tubes"], "extent": [4435, 4459]}], "container": true}, {"type": "dt", "indent": 4, "text": ["meta"], "extent": [4459, 4469], "body": [{"type": "para", "indent": 8, "text": ["Metaballs"], "extent": [4469, 4487]}], "container": true}, {"type": "dt", "indent": 4, "text": ["particle"], "extent": [4487, 4501], "body": [{"type": "para", "indent": 8, "text": ["Particle systems"], "extent": [4501, 4526]}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": ["The primitive types can be combined in standard Houdini grouping\n    mechanisms. For example:"], "extent": [4526, 4625]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["all,^p*"]}, ": select all primitive types except polygons and\n      particles."], "extent": [4625, 4707]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["face,surface"]}, ": select face and surface primitives."], "extent": [4707, 4766]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["*,^quad*,^meta"]}, ": Select any primitive but quadrics or metaballs."], "extent": [4766, 4839]}], "container": true}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "var", "text": ["allow_dragging"]}, " "], "extent": [4839, 4860], "body": [{"type": "para", "indent": 4, "text": ["If set to 1, the selection can be modified without forcing the user\n    to click ", {"keys": ["RMB"], "type": "keys", "text": null}, " to complete the selection."], "extent": [4860, 4981]}, {"type": "para", "indent": 4, "text": ["This lets the user select and modify in one step (dragging with the\n    mouse finishes selection and passes the mouse movements to the\n    operator handles)."], "extent": [4981, 5144]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "var", "text": ["group_type_parm"]}, " "], "extent": [5144, 5166], "body": [{"type": "para", "indent": 4, "text": ["The name of a parameter which indicates the geometry type the\n    selection group will have. Typically this value will name a\n    parameter with a menu for choosing ", {"type": "q", "text": ["Points"]}, ", ", {"type": "q", "text": ["Primitives"]}, ", or ", {"type": "q", "text": ["Guess\n    from group"]}, ". See the OMbindings file for the ", {"scheme": "Node", "value": "/nodes/sop/blast", "type": "link", "text": ["Blast\n    SOP"], "fullpath": "/nodes/sop/blast"}, "."], "extent": [5166, 5450]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "var", "text": ["asterisk_sel_all"]}, " "], "extent": [5450, 5473], "body": [{"type": "para", "indent": 4, "text": ["If set to 1, the selector needs to set the selection string to ", {"type": "q", "text": ["*"]}, "\n    to indicate all geometry was selected. If 0, the selector assumes an\n    empty group parameter means all geometry was selected."], "extent": [5473, 5676]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "var", "text": ["input_index"]}, " "], "extent": [5676, 5694], "body": [{"type": "para", "indent": 4, "text": ["For per-parameter selectors. When the user selects geometry, the\n    selector must connect the output from the selected operator to the\n    input of this operator. This parameter specifies the index of the\n    input number where the operator should be connected. Use -1 if the\n    selector needs to connect multiple input operators into this\n    operator."], "extent": [5694, 6054]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "var", "text": ["input_required"]}, " "], "extent": [6054, 6075], "body": [{"type": "para", "indent": 4, "text": ["For per-parameter selectors. Set to 1 if the user must select\n    geometry for this input."], "extent": [6075, 6175]}], "container": true}], "container": true}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n#pragma bindselector prims \"Switch Geometry\" \\\n    \"Choose the geometry to switch between\" \\\n    all 0 \"\" 0\n#pragma bindhandle input_number 0 ladder Input parm0\nsop switcher(int input_number=0) { import(\"P\", P, input_number) }\n"], "extent": [6175, 6416]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma bindselectorreserved"], "extent": [6416, 6452], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": [" #pragma bindselectorreserved ", {"type": "var", "text": ["reserved_parm_name"]}, " ", {"type": "var", "text": ["sel_type"]}, "\n", {"type": "var", "text": ["sel_name"]}, " ", {"type": "var", "text": ["sel_prompt"]}, " ", {"type": "var", "text": ["sel_mask"]}, " ", {"type": "var", "text": ["allow_dragging"]}, "\n", {"type": "var", "text": ["group_type_parm"]}, " ", {"type": "var", "text": ["asterisk_sel_all"]}, " ", {"type": "var", "text": ["input_index"]}, "\n", {"type": "var", "text": ["input_required"]}, " "]}], "extent": [6452, 6659]}, {"type": "para", "indent": 0, "text": ["Similar to the bindhandlereserved pragma, this binds selectors to\nreserved parameters in your scripted operators. The arguments to this\npragma are the same as those passed to the bindselector pragma. The only\ndifference is that the parameter name argument must specify a reserved\nparameter."], "extent": [6659, 6951]}]}, {"level": 2, "id": "callback", "container": true, "type": "h", "indent": 0, "text": ["#pragma callback"], "extent": [6951, 6985], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma callback ", {"type": "var", "text": ["name"]}, " \"", {"type": "var", "text": ["script"]}, "\""]}], "extent": [6985, 7028]}, {"type": "para", "indent": 0, "text": ["Binds a callback HScript script or Python function to the ", {"type": "var", "text": ["name"]}, " \nparameter. When the parameter changes, Houdini executes the ", {"type": "var", "text": ["script"]}, " \nstring."], "extent": [7028, 7177]}, {"type": "para", "indent": 0, "text": ["Because of architectural limitations in Houdini, the parameter and\nscript must meet certain conditions:"], "extent": [7177, 7282]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["The dialog script needs to be bound to a Houdini node (e.g. SHOP,\n  SOP, etc.)."], "extent": [7282, 7365]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The parameter must be either a toggle button, or have a menu bound to\n  it (see ", {"type": "code", "text": ["#pragma hint"]}, " and ", {"type": "code", "text": ["#pragma choice"]}, ")."], "extent": [7365, 7486]}], "container": true}, {"type": "para", "indent": 0, "text": ["To indicate the language of the callback (", {"type": "code", "text": ["hscript"]}, " or ", {"type": "code", "text": ["python"]}, "), use ", {"type": "code", "text": ["#pragma parmtag"]}, ". If you don\u2019t use a ", {"type": "code", "text": ["#pragma parmtag"]}, " for a callback the default is ", {"type": "code", "text": ["hscript"]}, ". However, the recommended method for programming callback scripts is ", {"type": "code", "text": ["python"]}, "."], "extent": [7486, 7732]}, {"lang": null, "type": "pre", "indent": 0, "text": ["\n#pragma callback parm1 \"message $script_parm\"\n#pragma parmtag parm1 script_callback_language hscript\n\n#pragma callback parm2 \"import hou; hou.ui.displayMessage(kwargs)\"\n#pragma parmtag initialize_menu script_callback_language hscript\n"], "extent": [7732, 7974]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["For HScript callbacks, ", {"type": "var", "text": ["script"]}, " can be an HScript statement or the \nname of a script on the ", {"type": "code", "text": ["$HOUDINI_PATH/scripts"]}, " path."], "extent": [7974, 8102]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["For Python callbacks, ", {"type": "var", "text": ["script"]}, " should be Python source code."], "extent": [8102, 8168]}], "container": true}, {"type": "para", "indent": 0, "text": ["Houdini executes ", {"type": "var", "text": ["script"]}, " in a context with certain variables available \nindicating which parameter changed."], "extent": [8168, 8280]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["For HScript callbacks, Houdini creates variables such as ", {"type": "code", "text": ["$node"]}, " \ncontaining the path to the node on which the parameter changed."], "extent": [8280, 8413]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["For Python callbacks, Houdini creates a ", {"type": "code", "text": ["kwargs"]}, " variable containing a \ndictionary of information about the parameter that changed."], "extent": [8413, 8548]}], "container": true}, {"type": "para", "indent": 0, "text": ["See ", {"scheme": null, "value": "/hom/locations#parameter_callback_scripts", "type": "link", "text": ["callback scripts"], "fullpath": "/hom/locations#parameter_callback_scripts", "fragment": "#parameter_callback_scripts"}, " for\nmore information."], "extent": [8548, 8636]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma disablewhen and #pragma hidewhen"], "extent": [8636, 8683], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma disablewhen ", {"type": "var", "text": ["parm_name"]}, " ", {"type": "var", "text": ["conditional_expression"]}]}], "extent": [8683, 8748]}, {"type": "para", "indent": 0, "text": ["Disables ", {"type": "var", "text": ["parm_name"]}, " when the ", {"type": "var", "text": ["conditional_expression"]}, " evaluates to true."], "extent": [8748, 8827]}, {"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma hidewhen ", {"type": "var", "text": ["parm_name"]}, " ", {"type": "var", "text": ["conditional_expression"]}]}], "extent": [8827, 8888]}, {"type": "para", "indent": 0, "text": ["Hides ", {"type": "var", "text": ["parm_name"]}, " from the UI when the ", {"type": "var", "text": ["conditional_expression"]}, " evaluates to true."], "extent": [8888, 8976]}, {"type": "para", "indent": 0, "text": ["The syntax of the ", {"type": "var", "text": ["conditional_expression"]}, " is the same as for the ", {"type": "ui", "text": ["Disable when"]}, " and\n", {"type": "ui", "text": ["Hide when"]}, " options on parameters. See the ", {"scheme": null, "value": "/ref/windows/optype#conditionals", "type": "link", "text": ["help for conditional rules"], "fullpath": "/ref/windows/optype#conditionals", "fragment": "#conditionals"}, "\nfor more information on the conditional syntax."], "extent": [8976, 9221]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n// Disable 'samples' parameter when 'enable' parameter is toggled off\n#pragma disablewhen samples { enable == 0 }\n\n// Hide 'choice_dep1' parameter when string menu 'choice' is set to 'off'.\n#pragma hidewhen choice_dep1 { choice == \"off\" }\n"], "extent": [9221, 9474]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma export"], "extent": [9474, 9500], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma export ", {"type": "var", "text": ["parm_name"]}, " (none | dialog | all)"]}], "extent": [9500, 9555]}, {"type": "para", "indent": 0, "text": ["Adds the parameter UI to the operation parameters dialog, and optionally\nalso the operator toolbar."], "extent": [9555, 9656]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["none"]}, " or 0"], "extent": [9656, 9669], "body": [{"type": "para", "indent": 4, "text": ["No export. The parameter only appears in the operator\u2019s standard\n    dialog."], "extent": [9669, 9750]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["dialog"]}, " or 1"], "extent": [9750, 9765], "body": [{"type": "para", "indent": 4, "text": ["The parameter appears in the operator\u2019s parameter window."], "extent": [9765, 9827]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["all"]}, " or 2"], "extent": [9827, 9839], "body": [{"type": "para", "indent": 4, "text": ["The parameter appears in the operator\u2019s parameter window and the\n    operator toolbar."], "extent": [9839, 9935]}], "container": true}], "container": true}, {"type": "para", "indent": 0, "text": ["You can use ", {"type": "code", "text": ["#pragma hint hidden"]}, " in combination with this pragma."], "extent": [9935, 10003]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma group"], "extent": [10003, 10023], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma group ", {"type": "var", "text": ["group_name"]}, " ", {"type": "var", "text": ["parameter_name1"]}, " ", {"type": "var", "text": ["parameter_name2"]}, " ..."]}], "extent": [10023, 10100]}, {"type": "para", "indent": 0, "text": ["Groups the named parameters into a tab in the UI."], "extent": [10100, 10151]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n// Group Ka, Kd, Ks, roughness into a folder called BRDF\n#pragma group BRDF Ka Kd Ks\n#pragma group BRDF roughness\n"], "extent": [10151, 10279]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [10279, 10286], "body": [{"type": "para", "indent": 4, "text": ["You can put ", {"type": "code", "text": ["/"]}, " in your group name to create nested groups. For example, the following creates a ", {"type": "code", "text": ["Group"]}, " tab with two sub-tabs."], "extent": [10286, 10418]}, {"lang": "vex", "type": "pre", "indent": 4, "text": ["\n    #pragma group \"Group/Sub Group 1\" p1 p2\n    #pragma group \"Group/Sub Group 2\" p3 p4\n    "], "extent": [10418, 10532]}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma help and #pragma info"], "extent": [10532, 10569], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma help \"", {"type": "var", "text": ["text"]}, "\""]}], "extent": [10569, 10597]}, {"type": "para", "indent": 0, "text": ["Adds ", {"type": "var", "text": ["text"]}, " to the help in the dialog script. You can use this to\ndocument functions and parameters for end-users."], "extent": [10597, 10715]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n#pragma help \"This is help for the VEX function.\"\n#pragma help \"It gets added automatically to the help text\"\n"], "extent": [10715, 10839]}, {"type": "para", "indent": 0, "text": ["Like ", {"type": "code", "text": ["#pragma help"]}, ", ", {"type": "code", "text": ["#pragma info"]}, " text is added to the help in the\ndialog script. However, the info text is in a separate section at the\nbeginning of the help. You can use this to specify copyrights, version\ninformation, etc."], "extent": [10839, 11069]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n#pragma info \"Created by Bob Loblaw - (c) 2006\"\n"], "extent": [11069, 11131]}, {"type": "para", "indent": 0, "text": ["Currently, only SOPs display info text."], "extent": [11131, 11173]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma hint"], "extent": [11173, 11192], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma hint ", {"type": "var", "text": ["parameter_name"]}, " ", {"type": "var", "text": ["hint_type"]}]}], "extent": [11192, 11242]}, {"type": "para", "indent": 0, "text": ["Adds information about what type of value a parameter represents (for\nexample, a VEX vector may represent a point in space, a color, or a\ndirection). The hint is used to specialize the UI for editing the\nvalue."], "extent": [11242, 11454]}, {"type": "para", "indent": 0, "text": ["The ", {"type": "var", "text": ["hint_type"]}, " can be one of the following:"], "extent": [11454, 11502]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["none"]}, " "], "extent": [11502, 11511], "body": [{"type": "para", "indent": 4, "text": ["No hint."], "extent": [11511, 11524]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["toggle"]}, " "], "extent": [11524, 11535], "body": [{"type": "para", "indent": 4, "text": ["The integer or float represents an on/off switch (where 1 is on and 0\n    is off)."], "extent": [11535, 11622]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["color"]}, " "], "extent": [11622, 11632], "body": [{"type": "para", "indent": 4, "text": ["The parameter is a color. The UI will provide color sliders."], "extent": [11632, 11697]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["direction"]}, " "], "extent": [11697, 11711], "body": [{"type": "para", "indent": 4, "text": ["The parameter is a direction. The UI will provide a gadget for\n    specifying direction."], "extent": [11711, 11804]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["vector"]}, " "], "extent": [11804, 11815], "body": [{"type": "para", "indent": 4, "text": ["The parameter is a 3D vector in space. The UI is the same as the\n    default UI for a parameter with 3 floats, but the channel names will\n    end with x, y, z instead of 1, 2, 3."], "extent": [11815, 11998]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["vector"]}, " "], "extent": [11998, 12009], "body": [{"type": "para", "indent": 4, "text": ["The parameter is a 4D vector in space. The UI is the same as the\n    default UI for a parameter with 4 floats, but the channel names will\n    end with x, y, z, w instead of 1, 2, 3, 4."], "extent": [12009, 12198]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["uv"]}, " "], "extent": [12198, 12205], "body": [{"type": "para", "indent": 4, "text": ["The vector parameter is UV coordinates. The UI is two entry fields\n    instead of three (the third component passed to VEX is always 0),\n    and the channel names will end with u, v instead of 1, 2."], "extent": [12205, 12408]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["uvw"]}, " "], "extent": [12408, 12416], "body": [{"type": "para", "indent": 4, "text": ["The vector parameter is UV coordinates. The UI is two entry fields\n    instead of three (the third component passed to VEX is always 0),\n    and the channel names will end with u, v instead of 1, 2."], "extent": [12416, 12619]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["angle"]}, " "], "extent": [12619, 12629], "body": [{"type": "para", "indent": 4, "text": ["The parameter is a direction vector. The UI will provide a direction\n    gadget."], "extent": [12629, 12714]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["file"]}, " "], "extent": [12714, 12723], "body": [{"type": "para", "indent": 4, "text": ["The string parameter is a filename. The UI adds a browser button for\n    specifying the file. (See also ", {"type": "code", "text": ["image"]}, " and ", {"type": "code", "text": ["geometry"]}, " below.)"], "extent": [12723, 12862]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["image"]}, " "], "extent": [12862, 12872], "body": [{"type": "para", "indent": 4, "text": ["The string parameter is a filename of an image file. The UI adds a\n    browser button for specifying the file, and the browser only\n    displays image file types."], "extent": [12872, 13039]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["geometry"]}, " "], "extent": [13039, 13052], "body": [{"type": "para", "indent": 4, "text": ["The string parameter is a filename of a geometry file. The UI adds a\n    browser button for specifying the file, and the browser only\n    displays geometry file types."], "extent": [13052, 13224]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["hidden"]}, " "], "extent": [13224, 13235], "body": [{"type": "para", "indent": 4, "text": ["Don\u2019t include this parameter in the parameter list. This is useful when \n    you intend a parameter to be overridden by a geometry attribute. This\n    is distinct from ", {"type": "code", "text": ["invisible"]}, ", as no underlying scene parameter will\n    be created."], "extent": [13235, 13474]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["invisible"]}, " "], "extent": [13474, 13488], "body": [{"type": "para", "indent": 4, "text": ["The created parameter will exist in the operator but hidden from the\n    user interface. Unlike ", {"type": "code", "text": ["hidden"]}, ", an actual scene parameter will get \n    created, just not shown."], "extent": [13488, 13663]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["inputinvisible"]}, " "], "extent": [13663, 13682], "body": [{"type": "para", "indent": 4, "text": ["For VOP operators built using ", {"type": "code", "text": ["#pragma optable vop"]}, ", this hint\n    indicates that the VOP input connector should be hidden by default when\n    creating new nodes. The input will still be accessible through the\n    ", {"type": "code", "text": ["more..."]}, " connector at the bottom of the VOP. This hint has no effect\n    when building non-VOP operator types or for export parameters."], "extent": [13682, 14037]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["oplist [", {"type": "var", "text": ["opfilter"]}, "]"]}, " "], "extent": [14037, 14063], "body": [{"type": "para", "indent": 4, "text": ["The parameter is a list of objects. You can optionally specify\n    ", {"type": "var", "text": ["opfilter"]}, "  to limit the types of\n    operators allowed in the list. Use ", {"type": "code", "text": ["#pragma parmtag"]}, " to resolve any\n    bundles or groups in the list of objects."], "extent": [14063, 14293]}, {"type": "para", "indent": 4, "text": ["See the list of possible operator filters below."], "extent": [14293, 14351]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["oppath [", {"type": "var", "text": ["opfilter"]}, "]"]}, " "], "extent": [14351, 14377], "body": [{"type": "para", "indent": 4, "text": ["The parameter is an object path. You can optionally specify\n    ", {"type": "var", "text": ["opfilter"]}, "   to limit the types of\n    operators that can be chosen."], "extent": [14377, 14521]}, {"type": "para", "indent": 4, "text": ["See the list of possible operator filters below."], "extent": [14521, 14579]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["joinnext"]}], "extent": [14579, 14591], "body": [{"type": "para", "indent": 4, "text": ["Put the parameter after this one on the same row in the GUI.\n    For narrow controls this can save space in the parameter editor."], "extent": [14591, 14730]}, {"type": "para", "indent": 4, "text": ["Example: ", {"type": "code", "text": ["#pragma hint myParm joinnext"]}], "extent": [14730, 14779]}], "container": true}], "container": true}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n#pragma hint __nondiffuse toggle // Define as a toggle button\n#pragma hint specularcolor color // This represents a color\n#pragma hint rest hidden         // Don't show rest parameter in UI\n#pragma hint mapname image       // This represents an image file\n#pragma hint nullobject oppath \"obj/null\" // Only null objects\n"], "extent": [14779, 15112]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma inputlabel"], "extent": [15112, 15138], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma inputlabel ", {"type": "var", "text": ["inputnum"]}, " \"", {"type": "var", "text": ["label"]}, "\""]}], "extent": [15138, 15186]}, {"type": "para", "indent": 0, "text": ["For VEX operator types, sets the label for an operator input. This label\nappears when the user presses the middle mouse button on one of the\noperator inputs. The ", {"type": "var", "text": ["inputnum"]}, " is the index of the input, starting at\n1."], "extent": [15186, 15404]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n#pragma inputlabel 1 \"Geometry to Modify\"\n"], "extent": [15404, 15460]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma label"], "extent": [15460, 15481], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma label ", {"type": "var", "text": ["parameter_name"]}, " \"", {"type": "var", "text": ["text"]}, "\""]}], "extent": [15481, 15529]}, {"type": "para", "indent": 0, "text": ["Specifies a descriptive label for a parameter."], "extent": [15529, 15577]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n#pragma label amp    \"Noise Amplitude\"\ndisplacement bumpy(float amp=0) {\n...\n}\n"], "extent": [15577, 15670]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma name ", {"type": "q", "text": ["text"]}], "extent": [15670, 15697], "body": [{"type": "para", "indent": 0, "text": ["Sets the label that appears in the UI. This pragma is obsolete since the\nlabel is now defined in the operator table definition."], "extent": [15697, 15827]}]}, {"level": 2, "id": "opicon", "container": true, "type": "h", "indent": 0, "text": ["#pragma opicon"], "extent": [15827, 15857], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma opicon \"", {"type": "var", "text": ["text"]}, "\""]}], "extent": [15857, 15887]}, {"type": "para", "indent": 0, "text": ["Use this pragma to set the icon to use for this operator type. It can be\na path to an external .icon or .bicon file, or the name of one of the\nstandard icons."], "extent": [15887, 16047]}, {"type": "para", "indent": 0, "text": ["vcc\u2019s ", {"type": "code", "text": ["-C"]}, " ", {"scheme": null, "value": "/vex/vcc#otl", "type": "link", "text": ["command line option"], "fullpath": "/vex/vcc#otl", "fragment": "#otl"}, "\noverrides this pragma."], "extent": [16047, 16117]}]}, {"level": 2, "id": "opinputs", "container": true, "type": "h", "indent": 0, "text": ["#pragma opmininputs and #pragma opmaxinputs"], "extent": [16117, 16178], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma opmininputs ", {"type": "var", "text": ["num"]}]}], "extent": [16178, 16210]}, {"type": "para", "indent": 0, "text": ["For VEX operator types, this sets the ", {"type": "em", "text": ["minimum"]}, " number of inputs that\nmust be connected to the operator. This value is ignored for SHOPs,\nwhich take no inputs. The operator will generate an error if fewer than\nthis many nodes are connected as inputs. The ", {"type": "code", "text": ["-t"]}, " ", {"scheme": null, "value": "vcc#otl", "type": "link", "text": ["command line\noption"], "fullpath": "/vex/vcc#otl", "fragment": "#otl"}, "  overrides this pragma."], "extent": [16210, 16525]}, {"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma opmaxinputs ", {"type": "var", "text": ["num"]}]}], "extent": [16525, 16556]}, {"type": "para", "indent": 0, "text": ["For VEX operator types, this sets the ", {"type": "em", "text": ["maximum"]}, " number of inputs that\ncan be connected to the operator. This value is ignored for SHOPs, which\ntake no inputs. The ", {"type": "code", "text": ["-T"]}, " ", {"scheme": null, "value": "vcc#otl", "type": "link", "text": ["command line option"], "fullpath": "/vex/vcc#otl", "fragment": "#otl"}, "\noverrides this pragma."], "extent": [16556, 16778]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n#pragma opmininputs 1\n#pragma opmaxinputs 4\n"], "extent": [16778, 16836]}]}, {"level": 2, "id": "opname", "container": true, "type": "h", "indent": 0, "text": ["#pragma opname and #pragma oplabel"], "extent": [16836, 16887], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma opname \"", {"type": "var", "text": ["text"]}, "\""]}], "extent": [16887, 16917]}, {"type": "para", "indent": 0, "text": ["Specifies the internal operator name of this operator type. By default\nthe compiler uses the name of the source file. vcc\u2019s ", {"type": "code", "text": ["-n"]}, " ", {"scheme": null, "value": "vcc#otl", "type": "link", "text": ["command line\noption"], "fullpath": "/vex/vcc#otl", "fragment": "#otl"}, "  overrides this pragma."], "extent": [16917, 17101]}, {"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma oplabel \"", {"type": "var", "text": ["text"]}, "\""]}], "extent": [17101, 17131]}, {"type": "para", "indent": 0, "text": ["Specifies a descriptive name for this operator type. By default the\ncompiler uses internal operator name. vcc\u2019s ", {"type": "code", "text": ["-N"]}, " ", {"scheme": null, "value": "vcc#otl", "type": "link", "text": ["command line\noption"], "fullpath": "/vex/vcc#otl", "fragment": "#otl"}, "  overrides this pragma."], "extent": [17131, 17303]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n#pragma opname \"myshop\"\n#pragma oplabel \"My New Shop\"\n"], "extent": [17303, 17371]}]}, {"level": 2, "id": "opscript", "container": true, "type": "h", "indent": 0, "text": ["#pragma opscript"], "extent": [17371, 17406], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma opscript \"", {"type": "var", "text": ["text"]}, "\""]}], "extent": [17406, 17438]}, {"type": "para", "indent": 0, "text": ["If this operator type is a shader that can be used from renderers other\nthan mantra, this pragma lets you set the name of the shader file that\nthe renderer should look for. If you use this pragma, the operator type\nname does not need to match the shader file name. vcc\u2019s ", {"type": "code", "text": ["-S"]}, "\n", {"scheme": null, "value": "/vex/vcc#otl", "type": "link", "text": ["command line option"], "fullpath": "/vex/vcc#otl", "fragment": "#otl"}, "  overrides this pragma."], "extent": [17438, 17774]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n#pragma opscript \"rman_myshader\"\n"], "extent": [17774, 17821]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma parmhelp parameter_name ", {"type": "q", "text": ["text"]}], "extent": [17821, 17867], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma parmhelp ", {"type": "var", "text": ["parameter_name"]}, " \"", {"type": "var", "text": ["text"]}, "\""]}], "extent": [17867, 17918]}, {"type": "para", "indent": 0, "text": ["Sets the tooltip that appears when the user hovers over\n", {"type": "var", "text": ["parameter_name"]}, "."], "extent": [17918, 17995]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n#pragma parmhelp amp \"Increase this value to add more noise.\"\ndisplacement bumpy(float amp=0) {\n...\n}\n"], "extent": [17995, 18111]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma parmtag"], "extent": [18111, 18134], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma parmtag ", {"type": "var", "text": ["parmName"]}, " ", {"type": "var", "text": ["token"]}, " ", {"type": "var", "text": ["value"]}]}], "extent": [18134, 18187]}, {"type": "para", "indent": 0, "text": ["Each parameter defined in an operator has a set of token/value tags\nassociated with it. This pragma adds a token/value pair to a parameter."], "extent": [18187, 18328]}, {"type": "para", "indent": 0, "text": ["The following tokens are available:"], "extent": [18328, 18365]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["autoscope"], "extent": [18365, 18376], "body": [{"type": "para", "indent": 4, "text": ["A ", {"type": "em", "text": ["string"]}, " of ones or zeros (for example ", {"type": "q", "text": ["1011"]}, ") corresponding\n    to each component of the parameter. 1 means the parameter is\n    auto-added to the channel list when the node is selected."], "extent": [18376, 18571]}, {"type": "para", "indent": 4, "text": ["If there aren\u2019t enough characters in the string for the number of\n    components, the last character will be extended for the remaining\n    components. This lets you specify ", {"type": "q", "text": ["1"]}, " to autoscope all components and ", {"type": "q", "text": ["0"]}, " to autoscope no components."], "extent": [18571, 18818]}, {"type": "para", "indent": 4, "text": ["If this tag is not defined for a parameter, Houdini guesses if a\n    parameter should be scoped or not."], "extent": [18818, 18927]}], "container": true}, {"type": "dt", "indent": 0, "text": ["editor"], "extent": [18927, 18935], "body": [{"type": "para", "indent": 4, "text": ["For string parameters, this can be used to show a multi-line editor\n    instead of a single-line input field. Specify ", {"type": "q", "text": ["1"]}, " to enable."], "extent": [18935, 19073]}], "container": true}, {"type": "dt", "indent": 0, "text": ["editorlines"], "extent": [19073, 19086], "body": [{"type": "para", "indent": 4, "text": ["If the multi-line editor is shown, this can be used to specify how many\n    lines of text are shown. The default value is ", {"type": "code", "text": ["10"]}, "."], "extent": [19086, 19223]}], "container": true}, {"type": "dt", "indent": 0, "text": ["opfilter"], "extent": [19223, 19233], "body": [{"type": "para", "indent": 4, "text": ["For parameters referring to object paths, this provides a filter for\n    which types of OPs will be presented in the OP chooser. If you set\n    this tag, you should also set the oprelative tag."], "extent": [19233, 19432]}, {"type": "para", "indent": 4, "text": ["This tag is also set by the ", {"type": "code", "text": ["  [#pragma hint\n    oppath|/vex/pragmas]  "]}, " pragma, but using a different\n    format."], "extent": [19432, 19552]}, {"type": "para", "indent": 4, "text": ["Possible values are:"], "extent": [19552, 19578]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["!!OBJ!!"], "extent": [19578, 19591], "body": [{"type": "para", "indent": 8, "text": ["Only show objects"], "extent": [19591, 19617]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!OBJ/GEOMETRY!!"], "extent": [19617, 19639], "body": [{"type": "para", "indent": 8, "text": ["Only show geometry objects"], "extent": [19639, 19674]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!OBJ/LIGHT!!"], "extent": [19674, 19693], "body": [{"type": "para", "indent": 8, "text": ["Only show light objects"], "extent": [19693, 19725]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!OBJ/CAMERA!!"], "extent": [19725, 19745], "body": [{"type": "para", "indent": 8, "text": ["Only show camera objects (lights are considered cameras)"], "extent": [19745, 19810]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!OBJ/BONE!!"], "extent": [19810, 19828], "body": [{"type": "para", "indent": 8, "text": ["Only show bone objects"], "extent": [19828, 19859]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!OBJ/FORCE!!"], "extent": [19859, 19878], "body": [{"type": "para", "indent": 8, "text": ["Only show force objects"], "extent": [19878, 19910]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SOP!!"], "extent": [19910, 19923], "body": [{"type": "para", "indent": 8, "text": ["Only show SOPs"], "extent": [19923, 19946]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!CHOP!!"], "extent": [19946, 19960], "body": [{"type": "para", "indent": 8, "text": ["Only show CHOPs"], "extent": [19960, 19984]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!COP2!!"], "extent": [19984, 19998], "body": [{"type": "para", "indent": 8, "text": ["Only show COPs"], "extent": [19998, 20021]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!VOP!!"], "extent": [20021, 20034], "body": [{"type": "para", "indent": 8, "text": ["Only show VOPs"], "extent": [20034, 20057]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!ROP!!"], "extent": [20057, 20070], "body": [{"type": "para", "indent": 8, "text": ["Only show output drivers (ROPs)"], "extent": [20070, 20110]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!DOP!!"], "extent": [20110, 20123], "body": [{"type": "para", "indent": 8, "text": ["Only show DOPs"], "extent": [20123, 20146]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SHOP!!"], "extent": [20146, 20160], "body": [{"type": "para", "indent": 8, "text": ["Only show SHOPs"], "extent": [20160, 20184]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SHOP/ATMOSPHERE!!"], "extent": [20184, 20209], "body": [{"type": "para", "indent": 8, "text": ["Only show atmosphere shader SHOPs"], "extent": [20209, 20251]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SHOP/BACKGROUND!!"], "extent": [20251, 20276], "body": [{"type": "para", "indent": 8, "text": ["Only show background shader SHOPs"], "extent": [20276, 20318]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SHOP/CONTOUR!!"], "extent": [20318, 20340], "body": [{"type": "para", "indent": 8, "text": ["Only show contour shader SHOPs"], "extent": [20340, 20379]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SHOP/CONTOUR_CONTRAST!!"], "extent": [20379, 20410], "body": [{"type": "para", "indent": 8, "text": ["Only show contour-contrast shader SHOPs"], "extent": [20410, 20458]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SHOP/CONTOUR_STORE!!"], "extent": [20458, 20486], "body": [{"type": "para", "indent": 8, "text": ["Only show contour-store shader SHOPs"], "extent": [20486, 20531]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SHOP/DISPLACEMENT!!"], "extent": [20531, 20558], "body": [{"type": "para", "indent": 8, "text": ["Only show displacement shader SHOPs"], "extent": [20558, 20602]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SHOP/EMITTER!!"], "extent": [20602, 20624], "body": [{"type": "para", "indent": 8, "text": ["Only show emitter shader SHOPs"], "extent": [20624, 20663]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SHOP/GEOMETRY!!"], "extent": [20663, 20686], "body": [{"type": "para", "indent": 8, "text": ["Only show geometry shader SHOPs"], "extent": [20686, 20726]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SHOP/IMAGE3D!!"], "extent": [20726, 20748], "body": [{"type": "para", "indent": 8, "text": ["Only show image3d shader SHOPs"], "extent": [20748, 20787]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SHOP/LENS!!"], "extent": [20787, 20806], "body": [{"type": "para", "indent": 8, "text": ["Only show lens shader SHOPs"], "extent": [20806, 20842]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SHOP/LIGHT!!"], "extent": [20842, 20862], "body": [{"type": "para", "indent": 8, "text": ["Only show light shader SHOPs"], "extent": [20862, 20899]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SHOP/LIGHT_SHADOW!!"], "extent": [20899, 20926], "body": [{"type": "para", "indent": 8, "text": ["Only show light-shadow shader SHOPs"], "extent": [20926, 20970]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SHOP/OUTPUT!!"], "extent": [20970, 20991], "body": [{"type": "para", "indent": 8, "text": ["Only show output shader SHOPs"], "extent": [20991, 21029]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SHOP/PHOTON!!"], "extent": [21029, 21050], "body": [{"type": "para", "indent": 8, "text": ["Only show photon shader SHOPs"], "extent": [21050, 21088]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SHOP/PHOTON_VOLUME!!"], "extent": [21088, 21116], "body": [{"type": "para", "indent": 8, "text": ["Only show photon volume shader SHOPs"], "extent": [21116, 21161]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SHOP/SURFACE!!"], "extent": [21161, 21183], "body": [{"type": "para", "indent": 8, "text": ["Only show surface shader SHOPs"], "extent": [21183, 21222]}], "container": true}, {"type": "dt", "indent": 4, "text": ["!!SHOP/SURFACE_SHADOW!!"], "extent": [21222, 21251], "body": [{"type": "para", "indent": 8, "text": ["Only show surface-shadow shader SHOPs"], "extent": [21251, 21297]}], "container": true}], "container": true}], "container": true}, {"type": "dt", "indent": 0, "text": ["oprelative"], "extent": [21297, 21309], "body": [{"type": "para", "indent": 4, "text": ["How paths should be resolved. Typically, the value of this token is\n    ", {"type": "q", "text": ["."]}, " so that paths are resolved relative to the current operator.\n    However, when referencing objects you can set the tag to ", {"type": "q", "text": ["/obj"]}, ". See\n    the example below."], "extent": [21309, 21546]}], "container": true}, {"type": "dt", "indent": 0, "text": ["opexpand"], "extent": [21546, 21556], "body": [{"type": "para", "indent": 4, "text": ["In SHOPs, causes ", {"type": "q", "text": ["oplist"]}, " parameters to be expanded to the full path\n    names. If a bundle or pattern is chosen, the pattern will be\n    expanded before it\u2019s sent to the renderer. See the example below."], "extent": [21556, 21764]}], "container": true}, {"type": "dt", "indent": 0, "text": ["opfullpath"], "extent": [21764, 21776], "body": [{"type": "para", "indent": 4, "text": ["When used in conjunction with the opexpand tag, causes the path\n    names of the objects to be fully qualified rather than relative to\n    the value of the oprelative tag. See the example below."], "extent": [21776, 21976]}], "container": true}, {"type": "dt", "indent": 0, "text": ["rampshowcontrolsdefault"], "extent": [21976, 22001], "body": [{"type": "para", "indent": 4, "text": ["Allows you to automatically hide ramp parameter controls, using a value of ", {"type": "code", "text": ["1"]}, " or ", {"type": "code", "text": ["0"]}, "."], "extent": [22001, 22093]}], "container": true}, {"type": "dt", "indent": 0, "text": ["script_callback"], "extent": [22093, 22110], "body": [{"type": "para", "indent": 4, "text": ["The callback script associated with the parameter. See ", {"scheme": null, "value": "#callback", "type": "link", "text": ["#pragma\n    callback"], "fullpath": "/vex/pragmas#callback", "fragment": "#callback"}, "."], "extent": [22110, 22208]}], "container": true}, {"type": "dt", "indent": 0, "text": ["script_ritype"], "extent": [22208, 22223], "body": [{"type": "para", "indent": 4, "text": ["Used when generating RIB streams and mapping the parameter to an\n    appropriate renderman type specification. The value should be a\n    valid renderman type (for example, ", {"type": "q", "text": ["uniform color"]}, ")."], "extent": [22223, 22417]}], "container": true}, {"type": "dt", "indent": 0, "text": ["script_unquoted"], "extent": [22417, 22434], "body": [{"type": "para", "indent": 4, "text": ["In VOP definitions, indicates the string parameter should be used in\n    an unquoted form. This allows strings from menus to be placed\n    verbatim in the code block (see the trig VOP)."], "extent": [22434, 22624]}], "container": true}, {"type": "dt", "indent": 0, "text": ["sop_input"], "extent": [22624, 22635], "body": [{"type": "para", "indent": 4, "text": ["Used internally by SOPs to determine the place to search for groups\n    when building a group menu of points/primitives."], "extent": [22635, 22761]}], "container": true}], "container": true}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n#pragma parmtag lightmask opfilter \"!!OBJ/LIGHT!!\"\n#pragma parmtag lightmask oprelative \"/obj\"\n#pragma parmtag lightmask opexpand 1\n#pragma parmtag reflectmask opfilter \"!!OBJ/GEOMETRY!!\"\n#pragma parmtag reflectmask opexpand 1\n#pragma parmtag reflectmask opfullpath 1\n"], "extent": [22761, 23043]}]}, {"level": 2, "id": "ramp", "container": true, "type": "h", "indent": 0, "text": ["#pragma ramp"], "extent": [23043, 23070], "body": [{"type": "para", "indent": 0, "text": ["Creates a ", {"scheme": null, "value": "/network/ramps", "type": "link", "text": ["ramp parameter"], "fullpath": "/network/ramps"}, " and connects it to shader\nfunction arguments."], "extent": [23070, 23160]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": ["#pragma ramp_rgb ", {"type": "var", "text": ["ramp_parm"]}, " ", {"type": "var", "text": ["basis_parm"]}, " ", {"type": "var", "text": ["keys_parm"]}, " ", {"type": "var", "text": ["values_parm"]}]}], "extent": [23160, 23240]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "code", "text": ["#pragma ramp_flt ", {"type": "var", "text": ["ramp_parm"]}, " ", {"type": "var", "text": ["basis_parm"]}, " ", {"type": "var", "text": ["keys_parm"]}, " ", {"type": "var", "text": ["values_parm"]}]}], "extent": [23240, 23321]}], "container": true}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n#pragma ramp_rgb color color_the_basis_strings color_the_key_positions color_the_key_values\n\nsurface\nsky(\n    string color_the_basis_strings[] = { \"linear\", \"linear\" };\n    float color_the_key_positions[] = { 0, 1};\n    vector color_the_key_values[] = { {0,0,0}, {0,0,1} };\n) { ... }\n"], "extent": [23321, 23619]}, {"type": "para", "indent": 0, "text": ["Unlike most other pragmas which set up UI for parameters defined in the shader,\nthe ramp pragma creates a new UI element in Houdini."], "extent": [23619, 23754]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": [{"type": "var", "text": ["ramp_parm"]}], "extent": [23754, 23769], "body": [{"type": "para", "indent": 4, "text": ["The name of the ramp parameter in the Houdini UI. It cannot conflict with any\n    parameters defined on the shader (or other ramps of course)."], "extent": [23769, 23917]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "var", "text": ["basis_parm"]}], "extent": [23917, 23933], "body": [{"type": "para", "indent": 4, "text": ["A parameter containing an array of strings. These strings determine the basis\n    values for each key (i.e. ", {"type": "q", "text": ["linear"]}, ", ", {"type": "q", "text": ["constant"]}, "). If a constant basis is to be\n    specified, then the basis_parm argument can be given as an empty string\n    (i.e. ", {"type": "q", "text": []}, "). However, the UI may not necessarily reflect this fact."], "extent": [23933, 24244]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "var", "text": ["keys_parm"]}], "extent": [24244, 24259], "body": [{"type": "para", "indent": 4, "text": ["A parameter containing an array of floats. If the spline is uniform\n    (i.e. has no keys), the keys_parm argument may be given as an empty string\n    (i.e. ", {"type": "q", "text": []}, "). However, the UI may not necessarily reflect this fact."], "extent": [24259, 24481]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "var", "text": ["values_parm"]}], "extent": [24481, 24498], "body": [{"type": "para", "indent": 4, "text": ["A parameter containing an array of floats or an array of vectors.\n    Unlike the basis or key parameter, this is mandatory."], "extent": [24498, 24627]}], "container": true}], "container": true}, {"type": "para", "indent": 0, "text": ["Default values are currently not supported by Houdini ramp parameters, so the\ninitial values given are not passed through to the UI."], "extent": [24627, 24761]}, {"type": "para", "indent": 0, "text": ["Although the values aren\u2019t passed, the number of keys given in the values\nparameter will be used to set the initial number of keys in the ramp."], "extent": [24761, 24906]}, {"type": "para", "indent": 0, "text": ["See ", {"scheme": null, "value": "/network/ramps", "type": "link", "text": ["ramp parameters"], "fullpath": "/network/ramps"}, " for more information."], "extent": [24906, 24966]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma range"], "extent": [24966, 24986], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma ", {"type": "var", "text": ["range"]}, " ", {"type": "var", "text": ["parameter_name"]}, "[!] ", {"type": "var", "text": ["min_value"]}, " ", {"type": "var", "text": ["max_value"]}, "[!]"]}], "extent": [24986, 25061]}, {"type": "para", "indent": 0, "text": ["Defines the ideal range for the parameter. If you append ", {"type": "code", "text": ["!"]}, "\nto a value, the parameter value will be clamped at that range.\nThe UI also uses this information to set the range of the slider."], "extent": [25061, 25252]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n#pragma range seed    0 10\n#pragma range roughness 0.001! 1!\n#pragma range gamma     0.001! 10\n"], "extent": [25252, 25361]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma rendermask"], "extent": [25361, 25387], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma rendermask (VMantra | RIB | OGL)"]}], "extent": [25387, 25432]}, {"type": "para", "indent": 0, "text": ["This pragma is only useful for SHOP dialog generation. Each SHOP has a\nmask defining which renderers can use the SHOP. It is possible to have a\nsimilar shader written in the RenderMan shading language and also in VEX\n(or another shading language). In this case, the rendermask can be\nspecified to include more than just VMantra."], "extent": [25432, 25762]}, {"type": "para", "indent": 0, "text": ["The rendermask parameter is closely bound to the code which generates\nscene descriptions for a renderer. Thus, the renderer names are quite\nspecific. The renderers which support SHOPs are\u2026"], "extent": [25762, 25954]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["RIB"], "extent": [25954, 25959], "body": [{"type": "para", "indent": 4, "text": ["RIB generation for RenderMan compliant renderers."], "extent": [25959, 26013]}], "container": true}, {"type": "dt", "indent": 0, "text": ["VMantra"], "extent": [26013, 26022], "body": [{"type": "para", "indent": 4, "text": ["The version of mantra which uses VEX for shading."], "extent": [26022, 26076]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OGL"], "extent": [26076, 26081], "body": [{"type": "para", "indent": 4, "text": ["OpenGL rendering. This is a special renderer which automatically\n    adds itself to most render masks. There is currently no way to\n    prevent this."], "extent": [26081, 26236]}], "container": true}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma optable"], "extent": [26236, 26258], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma optable vop"]}], "extent": [26258, 26282]}, {"type": "para", "indent": 0, "text": ["This pragma can be used to indicate which operator type to generate.\nCurrently the only supported option is ", {"type": "code", "text": ["vop"]}, " meaning to create a VOP\noperator."], "extent": [26282, 26431]}, {"type": "para", "indent": 0, "text": ["VOP otls generated using this option have a very specific structure:"], "extent": [26431, 26500]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["The inputs on the VOP are generated from non-export shader parameters"], "extent": [26500, 26572]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The outputs on the VOP are generated from export shader parameters"], "extent": [26572, 26641]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The parameters on the VOP are created for all non-export shader parameters, with UI generation working the same way it does for SHOP operators"], "extent": [26641, 26786]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The outer code imports the shader function from an external file using the ", {"scheme": null, "value": "shadercalls", "type": "link", "text": ["import"], "fullpath": "/vex/shadercalls"}, " directive"], "extent": [26786, 26894]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The inner code calls this shader using the ", {"scheme": null, "value": "shadercalls", "type": "link", "text": ["shader call"], "fullpath": "/vex/shadercalls"}, " syntax"], "extent": [26894, 26973]}], "container": true}, {"type": "para", "indent": 0, "text": ["Since the implementation of the shader is not actually stored in the\ngenerated VOP, it must be accessible through an external .vfl or .vex file\nfor the VOP to work correctly. Placing the .vfl or compiled .vex file for\nthe shader in a location accessible to the VEX search path will meet this\nrequirement."], "extent": [26973, 27279]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["#pragma rename"], "extent": [27279, 27300], "body": [{"type": "para", "indent": 0, "text": [{"type": "code", "text": ["#pragma rename ", {"type": "var", "text": ["oldname"]}, " ", {"type": "var", "text": ["newname"]}]}], "extent": [27300, 27343]}, {"type": "para", "indent": 0, "text": ["Specify a different name for the operator parameter than is used in the\nshader interface. This directive should occur after all other ", {"type": "code", "text": ["#pragmas"]}, "\nreferring to that parameter."], "extent": [27343, 27518]}, {"type": "para", "indent": 0, "text": ["When using ", {"type": "code", "text": ["#pragma optable vop"]}, ", this can be useful to allow a VOP input\nor output to use the same name as a VEX global variable, since such a name\ncollision is valid in VOPs but not in VEX."], "extent": [27518, 27711]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["How to create menus for parameters"], "extent": [27711, 27752], "body": [{"type": "para", "indent": 0, "text": ["You can define choice pragmas to create a menu UI for a parameter."], "extent": [27752, 27821]}, {"type": "para", "indent": 0, "text": ["You build the list for a parameter by doing one of the following:"], "extent": [27821, 27888]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Use multiple choice pragmas for a parameter to create menu items\n  (", {"type": "code", "text": ["choice"]}, ", ", {"type": "code", "text": ["choicescript"]}, ", ", {"type": "code", "text": ["choicereplace"]}, ", ", {"type": "code", "text": ["choicetoggle"]}, ")."], "extent": [27888, 28019]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Use one choicescript pragmas for a parameter to create a\n  script that creates the menu items (", {"type": "code", "text": ["choicescript"]}, ",\n  ", {"type": "code", "text": ["choicereplacescript"]}, ", ", {"type": "code", "text": ["choicetogglescript"]}, ")."], "extent": [28019, 28181], "body": [{"type": "para", "indent": 2, "text": ["This script is run whenever Houdini needs to generate the menu entries\n  (i.e. the generated values are not cached) so this script should be as\n  efficient as possible. The output of the script must be a series of\n  value/label pairs, which have the same meaning as the value and label\n  fields in the choice pragma."], "extent": [28181, 28501]}], "container": true}], "container": true}, {"type": "para", "indent": 0, "text": ["The plain ", {"type": "code", "text": ["choice"]}, " pragma creates a UI that only allows the user to\nchoose values from the menu. The ", {"type": "code", "text": ["choicereplace"]}, " pragma creates UI with\na menu but also lets the user enter a different value manually. The\n", {"type": "code", "text": ["choicetoggle"]}, " pragma allows user input, but also provides a menu where\nchoosing a menu item adds or removes it to/from the input."], "extent": [28501, 28841]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["#pragma choice ", {"type": "var", "text": ["parameter_name"]}, " \"", {"type": "var", "text": ["value"]}, "\" \"", {"type": "var", "text": ["label"]}, "\""]}], "extent": [28841, 28902], "body": [{"type": "para", "indent": 4, "text": ["Adds a menu item for ", {"type": "var", "text": ["parameter_name"]}, ". Displays a menu of mutually exclusive choices."], "extent": [28902, 28995]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["#pragma choicescript ", {"type": "var", "text": ["parameter_name"]}, " ", {"type": "var", "text": ["language"]}, " \"", {"type": "var", "text": ["scriptline"]}, "\""]}], "extent": [28995, 29068], "body": [{"type": "para", "indent": 4, "text": ["Defines a script that will generate menu items for\n    ", {"type": "var", "text": ["parameter_name"]}, ".  ", {"type": "var", "text": ["language"]}, " can be either ", {"type": "code", "text": ["python"]}, " or\n    ", {"type": "code", "text": ["hscript"]}, ". Displays a menu of mutually exclusive choices."], "extent": [29068, 29250]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["#pragma choicereplace ", {"type": "var", "text": ["parameter_name"]}, " \"", {"type": "var", "text": ["value"]}, "\" \"", {"type": "var", "text": ["label"]}, "\""]}], "extent": [29250, 29318], "body": [{"type": "para", "indent": 4, "text": ["Adds a menu item for ", {"type": "var", "text": ["parameter_name"]}, ".\n    Displays a UI where the user can choose an item from the menu or input their own."], "extent": [29318, 29450]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["#pragma choicereplacescript ", {"type": "var", "text": ["parameter_name"]}, " \"", {"type": "var", "text": ["scriptline"]}, "\""]}], "extent": [29450, 29517], "body": [{"type": "para", "indent": 4, "text": ["Defines a line in a script that will generate menu items for ", {"type": "var", "text": ["parameter_name"]}, ".\n    Displays a UI where the user can choose an item from the menu or input their own."], "extent": [29517, 29689]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["#pragma choicetoggle ", {"type": "var", "text": ["parameter_name"]}, " \"", {"type": "var", "text": ["value"]}, "\" \"", {"type": "var", "text": ["label"]}, "\""]}], "extent": [29689, 29756], "body": [{"type": "para", "indent": 4, "text": ["Adds a menu item for ", {"type": "var", "text": ["parameter_name"]}, ".\n    Displays a menu of choices that add/remove items to/from the user input."], "extent": [29756, 29879]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["#pragma choicetogglescript ", {"type": "var", "text": ["parameter_name"]}, " \"", {"type": "var", "text": ["scriptline"]}, "\""]}], "extent": [29879, 29945], "body": [{"type": "para", "indent": 4, "text": ["Defines a line in a script that will generate menu items for ", {"type": "var", "text": ["parameter_name"]}, ".\n    Displays a menu of choices that add/remove items to/from the user input."], "extent": [29945, 30108]}], "container": true}], "container": true}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n#pragma choice operation \"over\"    \"Composite A Over B\"\n#pragma choice operation \"under\"    \"Composite A Under B\"\n#pragma choice operation \"add\"    \"Add A and B\"\n#pragma choice operation \"sub\"    \"Subtract A from B\"\ncop texture(string operation=\"over\")\n{\nif (operation == \"over\") ...    // texture coordinates\nif (operation == \"under\") ...    // parametric coordinates\nif (operation == \"add\")     ...    // orthographic\nif (operation == \"sub\")     ...    // polar\n}\n"], "extent": [30108, 30588]}, {"type": "para", "indent": 0, "text": ["This would define a menu for the parameter ", {"type": "q", "text": ["operation"]}, ". The menu would\nconsist of 4 entries. The values for the string parameter would be one\nof ", {"type": "q", "text": ["over"]}, ", ", {"type": "q", "text": ["under"]}, ", ", {"type": "q", "text": ["add"]}, " or ", {"type": "q", "text": ["sub"]}, ". However, the user would be presented\nwith more meaningful labels for the operation types."], "extent": [30588, 30857]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n#pragma choice operation \"0\"    \"Use texture coordinates\"\n#pragma choice operation \"1\"    \"Use parametric coordinates\"\n#pragma choice operation \"2\"    \"Orthographic Projection\"\n#pragma choice operation \"3\"    \"Polar Projection\"\nsop texture(int operation=0)\n{\nif (operation == 0) ...    // texture coordinates\nif (operation == 1) ...    // parametric coordinates\nif (operation == 2) ...    // orthographic\nif (operation == 3) ...    // polar\n}\n"], "extent": [30857, 31314]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [31314, 31321], "body": [{"type": "para", "indent": 4, "text": ["You can use pragmas other than choicereplace and choicetoggle to\n    create menus for integer parameters, but the menu items ignore the\n    labels and simply number the choices starting at 0. The\n    choicereplace and choicetoggle pragmas are only valid for string\n    parameters."], "extent": [31321, 31607]}], "container": true}], "container": true, "role": "item_group"}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["#pragma ophidewhen 1"]}], "extent": [31607, 31631], "body": [{"type": "para", "indent": 4, "text": ["Adding this pragma to a VOP\u2019s outer code makes the VOP input visibility\n    follow parameter visibility defined by the hidewhen conditionnals. Inputs \n    must have parameter with matching names."], "extent": [31631, 31832]}], "container": true}, {"type": "dt", "indent": 0, "text": [{"type": "code", "text": ["#pragma opextraparm ", {"type": "var", "text": ["type"]}, " ", {"type": "var", "text": ["name_format"]}, " ", {"type": "var", "text": ["parm_name0"]}, " ", {"type": "var", "text": ["parm_name1"]}, " ..."]}], "extent": [31832, 31914], "body": [{"type": "para", "indent": 4, "text": ["Add this pragma to a VOP\u2019s outer code to define an external parameter binding.\n    ", {"type": "var", "text": ["type"]}, " is a vex variable type.\n    ", {"type": "var", "text": ["name_format"]}, " is a simple formatting string without spaces that can include %d or %s special character to refer to node parameter values.\n    ", {"type": "var", "text": ["parm_name0"]}, " and other trailing arguments are parameter names to use to fill the %d and %s special characters in ", {"type": "var", "text": ["name_format"]}, "."], "extent": [31914, 32316]}], "container": true}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Operator list filters"], "extent": [32316, 32344], "body": [{"type": "para", "indent": 0, "text": ["These are the parameters you can use for the ", {"type": "var", "text": ["opfilter"]}, " argument of\ncertain pragmas."], "extent": [32344, 32433]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["obj"], "extent": [32433, 32438], "body": [{"type": "para", "indent": 4, "text": ["Any object."], "extent": [32438, 32454]}], "container": true}, {"type": "dt", "indent": 0, "text": ["sop"], "extent": [32454, 32459], "body": [{"type": "para", "indent": 4, "text": ["Any SOP."], "extent": [32459, 32472]}], "container": true}, {"type": "dt", "indent": 0, "text": ["chop"], "extent": [32472, 32478], "body": [{"type": "para", "indent": 4, "text": ["Any CHOP."], "extent": [32478, 32492]}], "container": true}, {"type": "dt", "indent": 0, "text": ["cop"], "extent": [32492, 32497], "body": [{"type": "para", "indent": 4, "text": ["Any COP."], "extent": [32497, 32510]}], "container": true}, {"type": "dt", "indent": 0, "text": ["vop"], "extent": [32510, 32515], "body": [{"type": "para", "indent": 4, "text": ["Any VOP."], "extent": [32515, 32528]}], "container": true}, {"type": "dt", "indent": 0, "text": ["rop"], "extent": [32528, 32533], "body": [{"type": "para", "indent": 4, "text": ["Any ROP."], "extent": [32533, 32546]}], "container": true}, {"type": "dt", "indent": 0, "text": ["obj/geo"], "extent": [32546, 32555], "body": [{"type": "para", "indent": 4, "text": ["Any Geometry object."], "extent": [32555, 32580]}], "container": true}, {"type": "dt", "indent": 0, "text": ["obj/null"], "extent": [32580, 32590], "body": [{"type": "para", "indent": 4, "text": ["Any Null object."], "extent": [32590, 32611]}], "container": true}, {"type": "dt", "indent": 0, "text": ["obj/light"], "extent": [32611, 32622], "body": [{"type": "para", "indent": 4, "text": ["Any light."], "extent": [32622, 32637]}], "container": true}, {"type": "dt", "indent": 0, "text": ["obj/camera"], "extent": [32637, 32649], "body": [{"type": "para", "indent": 4, "text": ["Any camera."], "extent": [32649, 32665]}], "container": true}, {"type": "dt", "indent": 0, "text": ["obj/fog"], "extent": [32665, 32674], "body": [{"type": "para", "indent": 4, "text": ["Any Fog object."], "extent": [32674, 32694]}], "container": true}, {"type": "dt", "indent": 0, "text": ["obj/bone"], "extent": [32694, 32704], "body": [{"type": "para", "indent": 4, "text": ["Any bone."], "extent": [32704, 32718]}], "container": true}, {"type": "dt", "indent": 0, "text": ["shop/surface"], "extent": [32718, 32732], "body": [{"type": "para", "indent": 4, "text": ["Any surface SHOP."], "extent": [32732, 32754]}], "container": true}, {"type": "dt", "indent": 0, "text": ["shop/displace"], "extent": [32754, 32769], "body": [{"type": "para", "indent": 4, "text": ["Any Displace SHOP."], "extent": [32769, 32792]}], "container": true}, {"type": "dt", "indent": 0, "text": ["shop/interior"], "extent": [32792, 32807], "body": [{"type": "para", "indent": 4, "text": ["Any Interior SHOP."], "extent": [32807, 32830]}], "container": true}, {"type": "dt", "indent": 0, "text": ["shop/light"], "extent": [32830, 32842], "body": [{"type": "para", "indent": 4, "text": ["Any Light SHOP."], "extent": [32842, 32862]}], "container": true}, {"type": "dt", "indent": 0, "text": ["shop/shadow"], "extent": [32862, 32875], "body": [{"type": "para", "indent": 4, "text": ["Any Shadow SHOP."], "extent": [32875, 32896]}], "container": true}, {"type": "dt", "indent": 0, "text": ["shop/fog"], "extent": [32896, 32906], "body": [{"type": "para", "indent": 4, "text": ["Any Atmosphere SHOP."], "extent": [32906, 32931]}], "container": true}, {"type": "dt", "indent": 0, "text": ["shop/photon"], "extent": [32931, 32944], "body": [{"type": "para", "indent": 4, "text": ["Any Photon SHOP."], "extent": [32944, 32965]}], "container": true}, {"type": "dt", "indent": 0, "text": ["shop/image3d"], "extent": [32965, 32979], "body": [{"type": "para", "indent": 4, "text": ["Any Image3D SHOP."], "extent": [32979, 33001]}], "container": true}], "container": true}]}], "title": ["VEX compiler pragmas"]}