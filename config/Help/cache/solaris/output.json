{"type": "root", "attrs": {}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Writing out USD"], "extent": [0, 20]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [20, 37], "body": [{"type": "para", "indent": 0, "text": ["See ", {"scheme": null, "value": "usd", "type": "link", "text": ["USD basics"], "fullpath": "/solaris/usd"}, " and ", {"scheme": null, "value": "about_lops", "type": "link", "text": ["About LOP node"], "fullpath": "/solaris/about_lops"}, " for background information on USD and how LOP nodes generate USD layers."], "extent": [37, 165]}, {"type": "para", "indent": 0, "text": ["A LOP network either generates a USD stage, either from scratch or starting with a top-level USD file, possibly adding in USD layers from files. At the end of the network, you can write out the finished USD, which will often involve writing out multiple files: a top-level file and separate files for each layer."], "extent": [165, 479]}, {"type": "para", "indent": 0, "text": ["Layers being read from disk are always left unmodified by the save process, though an anonymous layer generated by LOP nodes may overwrite an existing layer file on disk."], "extent": [479, 652]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["How to"], "extent": [652, 665], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["The main node that writes out the USD is the ", {"scheme": "Node", "value": "/nodes/out/usd", "type": "link", "text": ["USD render node"], "fullpath": "/nodes/out/usd"}, ". This node is available as a LOP (which you can put at the end of the LOP network) or a ROP (which you can put in a render network and point at the LOP network you want to output)."], "extent": [665, 926], "body": [{"type": "para", "indent": 4, "text": ["(See ", {"scheme": null, "value": "#other", "type": "link", "text": ["other ways to write out USD"], "fullpath": "/solaris/output#other", "fragment": "#other"}, " below for more specialized options.)"], "extent": [926, 1010]}], "container": true}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can also use the ", {"scheme": "Node", "value": "/nodes/out/usdzip", "type": "link", "text": ["USD Zip render node"], "fullpath": "/nodes/out/usdzip"}, " which outputs a self-contained USDZ file. This file is an archive containing all the top-level USD, layer files, external files (such as textures) and so on."], "extent": [1010, 1230], "body": [{"type": "para", "indent": 4, "text": ["USDZ retains all the edit-ability of the ", {"type": "q", "text": ["loose"]}, " files with the convenience of a single file. It also has certain features that make reading USD directly out of the archive efficient. This is very useful for publishing USD on the Internet."], "extent": [1230, 1476]}], "container": true}], "container": true}]}, {"level": 2, "id": "filepaths", "container": true, "type": "h", "indent": 0, "text": ["Where the files go"], "extent": [1476, 1513], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["In the ", {"scheme": "Node", "value": "/nodes/out/usd", "type": "link", "text": ["USD render node"], "fullpath": "/nodes/out/usd"}, ", you specify a file path (in the ", {"type": "ui", "text": ["Output file"]}, " parameter) for the ", {"type": "q", "text": ["top-level"]}, " USD file, containing data from the root layer."], "extent": [1513, 1682], "body": [{"type": "para", "indent": 4, "text": ["In addition to this file, the node writes any layers that have their file path metadata set to their own USD files."], "extent": [1682, 1803]}], "container": true}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Layers that were imported from disk remember their file paths and are written out to those paths, relative to the top-level file."], "extent": [1803, 1936]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can use the ", {"scheme": "Node", "value": "/nodes/lop/configurelayer", "type": "link", "text": ["Configure Layer LOP"], "fullpath": "/nodes/lop/configurelayer"}, " to assign/change a file path for any layer in the network. When you render to USD the layer will be written out to disk."], "extent": [1936, 2122]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The ", {"scheme": "Node", "value": "/nodes/lop/sopimport", "type": "link", "text": ["SOP Import LOP"], "fullpath": "/nodes/lop/sopimport"}, " and ", {"scheme": "Node", "value": "/nodes/lop/sopcreate", "type": "link", "text": ["SOP Create LOP"], "fullpath": "/nodes/lop/sopcreate"}, " also let you specify a file path where the geometry will be written when you write out USD."], "extent": [2122, 2297]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["File paths in Houdini are usually specified relative to the HIP file (", {"type": "code", "text": ["$HIP/props/lamp.usd"]}, "), while paths in USD are recommended to be relative to the top-level file (", {"type": "code", "text": ["./props/lamp.usd"]}, "). The ", {"scheme": "Node", "value": "/nodes/out/usd", "type": "link", "text": ["USD render node"], "fullpath": "/nodes/out/usd"}, " has a default ", {"scheme": null, "value": "#processor", "type": "link", "text": ["output processor"], "fullpath": "/solaris/output#processor", "fragment": "#processor"}, " that translates paths to be relative to the top-level file as the node writes the USD."], "extent": [2297, 2654]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The ", {"type": "ui", "text": ["Flush Data After Each Frame"]}, " parameter on the render node controls whether it writes out data to disk after calculating each frame. This option can be used to generate a sequence of USD files each containing a single time sample (for example, ", {"type": "code", "text": ["lamp_0001.usd"]}, ", ", {"type": "code", "text": ["lamp_0002.usd"]}, ", and so on), or single files containing time sample data from all frames."], "extent": [2654, 3015]}], "container": true}]}, {"level": 2, "id": "processors", "container": true, "type": "h", "indent": 0, "text": ["Output processors"], "extent": [3015, 3052], "body": [{"type": "para", "indent": 0, "text": ["Output processors are Python plugins that can alter the file locations and file path strings used for external files."], "extent": [3052, 3172]}, {"type": "para", "indent": 0, "text": ["The USD render node starts with one default output processor the makes file path references in layer files relative."], "extent": [3172, 3291]}, {"level": 3, "id": "custom_proc", "container": true, "type": "h", "indent": 0, "text": ["Writing a custom output processor"], "extent": [3291, 3347], "body": [{"type": "ord_group", "body": [{"blevel": 2, "type": "ord", "indent": 0, "text": ["Create a new directory ", {"type": "code", "text": ["$HOUDINI_USER_PREFS_DIR/husdplugins/outputprocessors"]}, "."], "extent": [3347, 3430], "body": [{"type": "para", "indent": 4, "text": ["(We\u2019ll create the plugin in the user prefs directory in this example. Of course, if you could put the ", {"type": "code", "text": ["husdplugins/outputprocessors"]}, " directory under any directory on the Houdini path.)"], "extent": [3430, 3620]}], "container": true}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Inside ", {"type": "code", "text": ["$HOUDINI_USER_PREFS_DIR/husdplugins/outputprocessors"]}, ". create a Python file for your output processor plug-in. For example:"], "extent": [3620, 3755], "body": [{"lang": null, "type": "pre", "indent": 4, "text": ["\n    $HOUDINI_USER_PREFS_DIR/husdplugins/outputprocessors/outputreview.py\n    "], "extent": [3755, 3844]}], "container": true}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["In the Python plug=in file, sublcass the ", {"type": "code", "text": ["husd.outputprocessor.OutputProcessor"]}, " class."], "extent": [3844, 3935], "body": [{"type": "para", "indent": 4, "text": ["In the subclass, implement the ", {"type": "code", "text": ["name()"]}, " to return a unique name, and ", {"type": "code", "text": ["displayName()"]}, " method to return a string describing what the processor does (for example, ", {"type": "code", "text": ["Save Paths Relative to Output Path"]}, ")."], "extent": [3935, 4139]}, {"lang": "python", "type": "pre", "indent": 4, "text": ["\n    import hou\n    from husd.outputprocessor import OutputProcessor\n\n\n    class ReviewOutputProcessor(OutputProcessor):\n        def name(self):\n            return \"review\"\n        def displayName(self):\n            return \"Manually Review Every Output Path\"\n    "], "extent": [4139, 4426]}], "container": true}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["At the bottom of the file, define a function called ", {"type": "code", "text": ["usdOutputProcessor()"]}, " that takes no arguments and returns a ", {"type": "em", "text": ["single instance"]}, " of your class whenever it\u2019s called."], "extent": [4426, 4597], "body": [{"type": "para", "indent": 4, "text": ["The existence of this function is what marks this module as implementing an output processor (Houdini looks for modules containing this function), and how Houdini gets your output processor object (it does not instantiate your class directly, it always uses this function)."], "extent": [4597, 4876]}, {"lang": "python", "type": "pre", "indent": 4, "text": ["\n    import hou\n    from husd.outputprocessor import OutputProcessor\n\n\n    class ReviewOutputProcessor(OutputProcessor):\n        def name(self):\n            return __class__.__name__\n        def displayName(self):\n            return \"Display the list of output files\"\n\n\n    # Must have: module-level function to return a processor instance\n    outputprocessor = ReviewOutputProcessor()\n    def usdOutputProcessor():\n        return outputprocessor\n    "], "extent": [4876, 5351]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [5351, 5362], "body": [{"type": "para", "indent": 8, "text": ["You have to maintain and return a single instance because currently the render node currently calls the factory method over and over, every time it needs to call a method on the object, so currently you can only keep information between calls if you always return the same instance. This will probably change in a future version of Houdini."], "extent": [5362, 5712]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Override ", {"scheme": null, "value": "#processor_api", "type": "link", "text": ["API methods"], "fullpath": "/solaris/output#processor_api", "fragment": "#processor_api"}, " to implement your output processor. See the ", {"scheme": null, "value": "#processor_api", "type": "link", "text": ["output processor API"], "fullpath": "/solaris/output#processor_api", "fragment": "#processor_api"}, " below."], "extent": [5712, 5842], "body": [{"lang": "python", "type": "pre", "indent": 4, "text": ["\n    import hou\n    from husd.outputprocessor import OutputProcessor\n\n\n    class ReviewOutputProcessor(OutputProcessor):\n        def name(self):\n            return \"displayoutputfiles\"\n        def displayName(self):\n            return \"Display the list of output files\"\n\n        def processSavePath(self, asset_path, asset_is_layer):\n            # Make the asset path absolute\n            asset_path = hou.text.abspath(asset_path)\n\n            # This processor asks the user to manually rewrite every file path.\n            # This is just an example, don't do this! It would be annoying!\n            return hou.ui.readInput(\n                message=\"Rewrite this output file path if you want\",\n                initial_contents=asset_path,\n                buttons=(\"OK\",),\n            )\n\n        def processReferencePath(self, asset_path, source_path, asset_is_layer):\n            # Make file path pointers relative to the source file's location\n            return hou.text.relpath(asset_path, source_path)\n\n\n    # Must have: module-level function to return a processor instance\n    outputprocessor = ReviewOutputProcessor()\n    def usdOutputProcessor():\n        return outputprocessor\n    "], "extent": [5842, 7055]}], "container": true}], "container": true}]}, {"level": 3, "id": "processor_api", "container": true, "type": "h", "indent": 0, "text": ["Output Processor method API"], "extent": [7055, 7109], "body": [{"type": "box_group", "body": [{"ext": null, "type": "box", "indent": 0, "role": "item", "extent": [7109, 7116], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["hidden(self)"]}, "  \u2192 ", {"type": "code", "text": ["bool"]}], "extent": [7146, 7176], "body": [{"type": "para", "indent": 8, "text": ["If this method returns ", {"type": "code", "text": ["True"]}, ", this processor is not included in the list of output processors shown to the user. The default implementation always returns ", {"type": "code", "text": ["False"]}, "."], "extent": [7176, 7350]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["name(self)"]}, "  \u2192 ", {"type": "code", "text": ["str"]}, " (REQUIRED)"], "extent": [7350, 7388], "body": [{"type": "para", "indent": 8, "text": ["Returns a unique name for the processor."], "extent": [7388, 7438]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [7438, 7452], "body": [{"type": "para", "indent": 12, "text": ["You must override this method in your subclass, otherwise it will raise a ", {"type": "code", "text": ["NotImplementedError"]}, " exception when Houdini tries to instantiate your class."], "extent": [7452, 7617]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["displayName(self)"]}, "  \u2192 ", {"type": "code", "text": ["str"]}, " (REQUIRED)"], "extent": [7617, 7662], "body": [{"type": "para", "indent": 8, "text": ["Returns a label to describe the processor, in the list of output processors shown to the user."], "extent": [7662, 7766]}, {"type": "para", "indent": 8, "text": ["The label should describe the function/of the processor, for example: ", {"type": "code", "text": ["Save Paths Relative to Output Path"]}, "."], "extent": [7766, 7883]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [7883, 7897], "body": [{"type": "para", "indent": 12, "text": ["You must override this method in your subclass, otherwise it will raise a ", {"type": "code", "text": ["NotImplementedError"]}, " exception when Houdini tries to instantiate your class."], "extent": [7897, 8062]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["parameters(self)"]}, "  \u2192 ", {"type": "code", "text": ["str"]}], "extent": [8062, 8095], "body": [{"type": "para", "indent": 8, "text": ["Returns a string containing Houdini ", {"type": "q", "text": ["dialog script"]}, " describing the parameters this processor shows to the user for configuration."], "extent": [8095, 8234]}, {"type": "para", "indent": 8, "text": ["The default implementation returns the script for an empty parameter group, so ", {"type": "strong", "text": ["if your processor doesn\u2019t need any parameters, you don\u2019t need to override this method"]}, "."], "extent": [8234, 8411]}, {"type": "para", "indent": 8, "text": ["You can generate the dialog script by building up a ", {"scheme": "Hom", "value": "/hom/hou/ParmTemplateGroup", "type": "link", "text": "", "fallback_text": "hou.ParmTemplateGroup", "fullpath": "/hom/hou/ParmTemplateGroup"}, "\n        with ", {"scheme": "Hom", "value": "/hom/hou/ParmTemplate", "type": "link", "text": "", "fallback_text": "hou.ParmTemplate", "fullpath": "/hom/hou/ParmTemplate"}, " objects inside, and then returning the value\n        from ", {"scheme": "Hom", "value": "/hom/hou/ParmTemplateGroup#asDialogScript", "type": "link", "text": "", "fallback_text": "hou.ParmTemplateGroup.asDialogScript", "fullpath": "/hom/hou/ParmTemplateGroup#asDialogScript", "fragment": "#asDialogScript"}, "."], "extent": [8411, 8638]}, {"lang": "python", "type": "pre", "indent": 8, "text": ["\n        group = hou.ParmTemplateGroup()\n        group.append(hou.StringParmTemplate(\n            \"texturedir\",\n            \"Texture Directory\",\n            string_type=hou.stringParmType.FileReference\n        ))\n        return group.asDialogScript()\n        "], "extent": [8638, 8929]}, {"type": "para", "indent": 8, "text": ["The internal names of any parameters you create here must be unique\n        among all other parameters on the render node, so you probably want to\n        use a naming scheme like ", {"type": "code", "text": [{"type": "var", "text": ["modulename"]}, "_", {"type": "var", "text": ["parmname"]}]}, " (where ", {"type": "var", "text": ["modulename"]}, " is the name of the Python module under ", {"type": "code", "text": ["husdplugins/outputprocessors"]}, ")."], "extent": [8929, 9243]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["beginSave(self, config_node, config_overrides, t)"]}], "extent": [9243, 9300], "body": [{"type": "para", "indent": 8, "text": ["Called when a render node using this processor starts to write out files. This gives you the chance to read parameter values (either the configuration parameters added by parameters(), or the render node\u2019s own parameters, depending on what information you need)."], "extent": [9300, 9572]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["config_node"]}], "extent": [9572, 9595], "body": [{"type": "para", "indent": 12, "text": ["A ", {"scheme": "Hom", "value": "/hom/hou/Node", "type": "link", "text": "", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node"}, " object representing the render node."], "extent": [9595, 9662]}], "container": true}, {"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["config_overrides"]}], "extent": [9662, 9690], "body": [{"type": "para", "indent": 12, "text": ["A ", {"type": "code", "text": ["dict"]}, " of values that should be used to override whatever may be set on the node. The ", {"type": "code", "text": ["OutputProcessor.evalConfig"]}, " method can be used to query a configuration value, accepting the override value from this dictionary if available, otherwise falling back to evaluating the matching parameter on the ", {"type": "code", "text": ["config_node"]}, "."], "extent": [9690, 10017]}], "container": true}, {"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["t"]}], "extent": [10017, 10030], "body": [{"type": "para", "indent": 12, "text": ["A floating point value representing the time (in seconds) along the timeline which the node is rendering. If you read parameter values from the node, you should use ", {"type": "code", "text": ["Parm.evalAtTime(t)"]}, " in case the parameter is animated."], "extent": [10030, 10264]}], "container": true}], "container": true}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["processSavePath(self, asset_path, is_layer)"]}, "  \u2192 ", {"type": "code", "text": ["str"]}], "extent": [10264, 10324], "body": [{"type": "para", "indent": 8, "text": ["Called when the render node needs to determine where on disk to save an asset. The ", {"type": "code", "text": ["asset_path"]}, " is the file path as Houdini knows it (for example, from USD metadata or a Houdini parameter)."], "extent": [10324, 10523]}, {"type": "para", "indent": 8, "text": ["This should return an absolute path to where the asset should be saved.\n        (If you return a relative path from this method, it will be relative to the current directory (", {"type": "code", "text": ["os.getcwd()"]}, ") which is probably not what you want.)"], "extent": [10523, 10760]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["asset_path"]}], "extent": [10760, 10782], "body": [{"type": "para", "indent": 12, "text": ["The path to the asset, as specified in Houdini. This string comes with expressions and environment variables (such as ", {"type": "code", "text": ["$HIP"]}, ") expanded already, so if you want to compare to another path, you should also expand that path (for example, with ", {"type": "code", "text": ["os.path.expandvars()"]}, " or ", {"type": "code", "text": ["hou.text.expandString()"]}, ")."], "extent": [10782, 11088]}], "container": true}, {"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["is_layer"]}], "extent": [11088, 11108], "body": [{"type": "para", "indent": 12, "text": ["A boolean value indicating whether this asset is a USD layer file. If this is ", {"type": "code", "text": ["False"]}, ", the asset is something else (for example, a texture or volume file)."], "extent": [11108, 11277]}], "container": true}], "container": true}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [11277, 11291], "body": [{"type": "para", "indent": 12, "text": ["Only the first processor in line sees the ", {"type": "code", "text": ["asset_path"]}, " as it was originally in Houdini. For all other processors in line, they receive the absolute path the first call returned."], "extent": [11291, 11482]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["processReferencePath(self, asset_path, asset_saved_path, source_path, is_layer)"]}, "  \u2192 ", {"type": "code", "text": ["str"]}], "extent": [11482, 11578], "body": [{"type": "para", "indent": 8, "text": ["Called when the render node needs to write a file path pointing to an asset (to sublayer or reference in the file)."], "extent": [11578, 11703]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["asset_path"]}], "extent": [11703, 11725], "body": [{"type": "para", "indent": 12, "text": ["The path to the asset, as specified in Houdini. This is the same string as would have been passed to ", {"type": "code", "text": ["processSavePath()"]}, " when the asset was saved. The return value from that call is passed to this method as ", {"type": "code", "text": ["asset_saved_path"]}, "."], "extent": [11725, 11973]}], "container": true}, {"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["asset_saved_path"]}], "extent": [11973, 12001], "body": [{"type": "para", "indent": 12, "text": ["The processed, absolute save location of the asset. This string comes with expressions and environment variables (such as ", {"type": "code", "text": ["$HIP"]}, ") expanded already, so if you want to compare to\n            another path, you should also expand that path (for example, with\n            ", {"type": "code", "text": ["os.path.expandvars()"]}, " or ", {"type": "code", "text": ["hou.text.expandString()"]}, ")."], "extent": [12001, 12343]}], "container": true}, {"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["source_path"]}], "extent": [12343, 12366], "body": [{"type": "para", "indent": 12, "text": ["The processed, absolute save location of the ", {"type": "q", "text": ["source"]}, " file containing the pointer being written. You can use this to make the path pointer relative. (For example, ", {"type": "code", "text": ["hou.text.relpath(asset_saved_path, source_path)"]}, ")."], "extent": [12366, 12602]}], "container": true}, {"type": "dt", "indent": 8, "text": [{"type": "code", "text": ["is_layer"]}], "extent": [12602, 12622], "body": [{"type": "para", "indent": 12, "text": ["A boolean value indicating whether this asset is a USD layer file. If this is ", {"type": "code", "text": ["False"]}, ", the asset is something else (for example, a texture or volume file)."], "extent": [12622, 12792]}], "container": true}], "container": true}], "container": true}], "container": true}], "container": true, "attrs": {"display": "rounded silver"}}], "container": true, "role": "item_group"}]}, {"level": 3, "id": "proc_scripting", "container": true, "type": "h", "indent": 0, "text": ["Adding an output processor in a script"], "extent": [12792, 12856], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Houdini will use an output processor on a ", {"scheme": "Node", "value": "/nodes/out/usd", "type": "link", "text": ["USD render node"], "fullpath": "/nodes/out/usd"}, " if the node instance has a ", {"scheme": null, "value": "/network/spare", "type": "link", "text": ["spare checkbox parameter"], "fullpath": "/network/spare"}, " named ", {"type": "code", "text": ["enableoutputprocessor_", {"type": "var", "text": ["modulename"]}]}, " that is turned on (where ", {"type": "var", "text": ["modulename"]}, " is the name of the Python module under ", {"type": "code", "text": ["husdplugins/outputprocessors"]}, ")."], "extent": [12856, 13159], "body": [{"type": "para", "indent": 4, "text": ["For example, if you implemented your class in ", {"type": "code", "text": ["$HOUDINI_USER_PREFS_DIR/husdplugins/outputprocessors/myprocessor.py"]}, ", then you would need to have a spare checkbox parameter named ", {"type": "code", "text": ["enableoutputprocessor_myprocessor"]}, " on a node to activate the processor for that node."], "extent": [13159, 13429]}], "container": true}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["This means you can enable a processor by creating the correct parameter and turning it on, such as in a script, even if the processor is hidden from the processor list in the user interface (see the ", {"type": "code", "text": ["hidden()"]}, " method above)."], "extent": [13429, 13657], "body": [{"type": "para", "indent": 4, "text": ["You can disable a processor by turning off the spare checkbox, or deleting the spare parameter."], "extent": [13657, 13758]}], "container": true}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["If the output processor has additional parameters for configuring it (see the ", {"type": "code", "text": ["parameters()"]}, " method above), you can create and fill in those parameters in a script as well."], "extent": [13758, 13935]}], "container": true}]}]}, {"level": 2, "id": "anim", "container": true, "type": "h", "indent": 0, "text": ["Saving animation"], "extent": [13935, 13965], "body": [{"type": "para", "indent": 0, "text": ["The ", {"type": "ui", "text": ["Flush Data After Each Frame"]}, " parameter on the USD render node controls whether it writes data out after each frame of data is generated. This feature can be used to create individual files containing the data for each frame, or arbitrarily large files containing time sample data across all frames."], "extent": [13965, 14273]}, {"type": "para", "indent": 0, "text": ["When the USD render node writes out a frame range with ", {"type": "ui", "text": ["Flush Data After Each Frame"]}, " off:"], "extent": [14273, 14366]}, {"type": "ord_group", "body": [{"blevel": 2, "type": "ord", "indent": 0, "text": ["For each frame the ROP will generate a set of layers ready to be saved to disk, but which still exist in-memory."], "extent": [14366, 14482]}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["It uses ", {"scheme": "Node", "value": "/nodes/out/usdstitch", "type": "link", "text": ["USD Stitch"], "fullpath": "/nodes/out/usdstitch"}, " to combine the generated frames with previously cooked frames in-memory."], "extent": [14482, 14598]}], "container": true}, {"type": "para", "indent": 0, "text": ["If the LOP Network is generating a lot of data, this can quickly use a lot of memory (even though the stitch operation does not duplicate data which is the same from frame to frame)."], "extent": [14598, 14782]}, {"type": "para", "indent": 0, "text": ["If you find writing out animated USD runs out of memory in Houdini, you can enable this option to limit Houdini to only have a single frame\u2019s data in memory at any one time. The result may take longer to write to disk, and the final file size may be larger than with this option disabled. But the amount of data that can be written will not be limited by the computer\u2019s available memory."], "extent": [14782, 15171]}, {"type": "para", "indent": 0, "text": ["Another approach is to write out a sequence of USD files each containing a single time sample of data, then using the ", {"scheme": "Node", "value": "/nodes/out/usdstitchclips", "type": "link", "text": ["USD Stitch Clips ROP"], "fullpath": "/nodes/out/usdstitchclips"}, " to generate a USD value clip. This approach only works if there is an isolated branch in the scene graph tree where the large data set exists, and the data for this branch can be written to a separate USD file."], "extent": [15171, 15549]}]}, {"level": 2, "id": "other", "container": true, "type": "h", "indent": 0, "text": ["Other ways to write out USD"], "extent": [15549, 15591], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can use Python (interactively in a Python shell or procedurally in a ", {"scheme": "Node", "value": "/nodes/lop/pythonscript", "type": "link", "text": ["Python Script LOP"], "fullpath": "/nodes/lop/pythonscript"}, ") to write out individual layers."], "extent": [15591, 15743]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can right-click a node, open the ", {"type": "ui", "text": ["LOP Actions"]}, " sub-menu, and choose ", {"type": "ui", "text": ["Inspect flattened stage"]}, " or ", {"type": "ui", "text": ["Inspect active layer"]}, ". These menu items open a viewer window showing the stage/layer as ", {"scheme": null, "value": "usd", "type": "link", "text": [{"type": "code", "text": ["usda"]}, " code"], "fullpath": "/solaris/usd"}, ". You can save the ", {"type": "code", "text": ["usda"]}, " code to a file from this window."], "extent": [15743, 16020]}], "container": true}]}], "title": ["Writing out USD"]}