{"type": "root", "attrs": {"type": "node", "context": "sop", "namespace": "kinefx", "internal": "rigdoctor", "icon": "SOP/kinefx-rigdoctor", "tags": "character", "since": "18.5", "version": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Rig Doctor"], "extent": [125, 140]}, {"type": "summary", "indent": 0, "text": ["Optimize and run checks on a SOP skeleton"], "extent": [140, 190]}, {"type": "para", "indent": 0, "text": ["This node provides a convenient way of placing 'breakpoints' in your network after performing modifications to a skeleton\u2019s topology (i.e. having added, removed or reparented joints), allowing you to take advantage of optimizations based upon a constant skeleton topology and/or name attribute in your downstream network. A constant copy of the input skeleton is stored based upon either a frame or a manually stashed copy and transfers attributes to this copy from the input."], "extent": [190, 668]}, {"type": "para", "indent": 0, "text": ["Any attribute entered in the ", {"type": "ui", "text": ["Freeze Attributes"]}, " parameter will not be copied from the animation and will remain constant on the output."], "extent": [668, 808]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [808, 820], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Freeze Time Dependent Attributes"], "extent": [820, 855], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Method"], "extent": [855, 867], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": ["Stash"], "extent": [888, 903], "body": [{"type": "para", "indent": 12, "text": ["Manually stash the input at the current frame."], "extent": [903, 963]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Time Shift"], "extent": [963, 983], "body": [{"type": "para", "indent": 12, "text": ["Take the topology from the input at the frame specified in ", {"type": "ui", "text": ["Frame"]}, "."], "extent": [983, 1066]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "method"}}, {"type": "dt", "indent": 4, "text": ["Frame"], "extent": [1066, 1077], "body": [{"type": "para", "indent": 8, "text": ["The frame at which to store the topology."], "extent": [1096, 1147]}], "container": true, "attrs": {"id": "frame"}}, {"type": "dt", "indent": 4, "text": ["StashInput"], "extent": [1147, 1163], "body": [{"type": "para", "indent": 8, "text": ["Stash the input topology at the current frame."], "extent": [1187, 1243]}], "container": true, "attrs": {"id": "stashinput"}}, {"type": "dt", "indent": 4, "text": ["Attributes To Freeze"], "extent": [1243, 1269], "body": [{"type": "para", "indent": 8, "text": ["A list of attributes to freeze along with the skeleton\u2019s topology."], "extent": [1296, 1372]}], "container": true, "attrs": {"id": "freezeattribs"}}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Point Names"], "extent": [1372, 1385], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Initialize Missing Names"], "extent": [1385, 1415], "body": [{"type": "para", "indent": 8, "text": ["Find any points with an empty name attribute and initialize the name using the ", {"type": "ui", "text": ["Prefix"]}, " specified. The prefix will be appended by a number that increases per missing name starting at 0."], "extent": [1445, 1642]}], "container": true, "attrs": {"id": "initmissingnames"}}, {"type": "dt", "indent": 4, "text": ["Prefix"], "extent": [1642, 1654], "body": [{"type": "para", "indent": 8, "text": ["The prefix to be used for initializing any empty point names."], "extent": [1678, 1749]}], "container": true, "attrs": {"id": "nameprefix"}}, {"type": "dt", "indent": 4, "text": ["Sanitize Names"], "extent": [1749, 1769], "body": [{"type": "para", "indent": 8, "text": ["When ", {"type": "ui", "text": ["Sanitize Names"]}, " is enabled, the node will check through the the point names, resolving any duplicates and names with spaces - any spaces in a given point\u2019s name will be replaced with an underscore."], "extent": [1796, 2011]}], "container": true, "attrs": {"id": "sanitizenames"}}, {"type": "dt", "indent": 4, "text": ["Store Input Name As"], "extent": [2011, 2036], "body": [{"type": "para", "indent": 8, "text": ["Store the input name to the specified point string attribute."], "extent": [2065, 2136]}], "container": true, "attrs": {"id": "inputnameattrib"}}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Hierarchy"], "extent": [2136, 2147], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["On Failure"], "extent": [2147, 2163], "body": [{"type": "para", "indent": 8, "text": ["Choose how the node handles a failed traversal of the skeleton\u2019s hierarchy"], "extent": [2186, 2278]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": ["Warning"], "extent": [2278, 2295], "body": [{"type": "para", "indent": 12, "text": ["Display a node warning but still allow the geometry to pass through."], "extent": [2295, 2377]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Error"], "extent": [2377, 2392], "body": [{"type": "para", "indent": 12, "text": ["Display a node error and interrupt the cooking of the downstream network."], "extent": [2392, 2479]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "onfailure"}}, {"type": "dt", "indent": 4, "text": ["Debug Hierarchy"], "extent": [2479, 2500], "body": [{"type": "para", "indent": 8, "text": ["Attempt to traverse the input geometry as a SOP skeleton."], "extent": [2528, 2595]}], "container": true, "attrs": {"id": "debughierarchy"}}, {"type": "dt", "indent": 4, "text": ["Output Parent Index"], "extent": [2595, 2620], "body": [{"type": "para", "indent": 8, "text": ["Output a ", {"type": "code", "text": ["parent_idx"]}, " point attribute with its value set to the point number of a given point\u2019s parent."], "extent": [2649, 2762]}], "container": true, "attrs": {"id": "outputparentidx"}}, {"type": "dt", "indent": 4, "text": ["Output Child Indices"], "extent": [2762, 2788], "body": [{"type": "para", "indent": 8, "text": ["Output an integer array point attribute containing the point numbers of each point\u2019s children."], "extent": [2820, 2924]}], "container": true, "attrs": {"id": "outputchildindices"}}, {"type": "dt", "indent": 4, "text": ["Output Evaluation Order"], "extent": [2924, 2953], "body": [{"type": "para", "indent": 8, "text": ["Output an integer point attribute set to the order in which the point appeared in the traversal."], "extent": [2980, 3086]}], "container": true, "attrs": {"id": "outputevalord"}}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Transformations"], "extent": [3086, 3103], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Initialize Transforms"], "extent": [3103, 3130], "body": [{"type": "para", "indent": 8, "text": ["Create a ", {"type": "code", "text": ["3@transform"]}, " attribute on the points if missing and initialize to identity."], "extent": [3158, 3253]}], "container": true, "attrs": {"id": "inittransforms"}}, {"type": "dt", "indent": 4, "text": ["Convert Instance Attributes"], "extent": [3253, 3286], "body": [{"type": "para", "indent": 8, "text": ["Set the ", {"type": "code", "text": ["3@transform"]}, " attribute based upon other point instance attributes, as recognized by the ", {"scheme": "Node", "value": "/nodes/sop/copytopoints", "type": "link", "text": ["Copy To Points SOP"], "fullpath": "/nodes/sop/copytopoints"}, ".\n        For orientation, ", {"type": "code", "text": ["4@orient"]}, " will be used if present.\n        If ", {"type": "code", "text": ["4@orient"]}, " is not present then the combination of ", {"type": "code", "text": ["v@N"]}, " and ", {"type": "code", "text": ["v@up"]}, " will be used, setting the Z-axis of the transform to ", {"type": "code", "text": ["v@N"]}, " and the Y-axis to ", {"type": "code", "text": ["v@up"]}, ".\n        If none of the above are present then the orientations will be identity."], "extent": [3322, 3777]}, {"type": "para", "indent": 8, "text": ["For scales, ", {"type": "code", "text": ["v@scale"]}, " will be used if present.\n        If ", {"type": "code", "text": ["v@scale"]}, " is not present then ", {"type": "code", "text": ["f@pscale"]}, " will be used.\n        Otherwise the scales will be set to identity."], "extent": [3777, 3953]}], "container": true, "attrs": {"id": "convertinstanceattribs"}}, {"type": "dt", "indent": 4, "text": ["Re-Orient To Child"], "extent": [3953, 3977], "body": [{"type": "para", "indent": 8, "text": ["If enabled the node will perform a simple reorienting of the points transforms to point the vector specified by ", {"type": "ui", "text": ["Vector To Child"]}, " to the next joint in the chain. If the point has multiple children the average position will be used.\n        Leaf joints will use their parent position as the reference for the orientation."], "extent": [4006, 4346]}, {"type": "note_group", "body": [{"type": "note", "indent": 8, "role": "item", "extent": [4346, 4360], "body": [{"type": "para", "indent": 12, "text": ["This action takes place after ", {"type": "ui", "text": ["Convert Instance Attributes"]}, " if enabled."], "extent": [4360, 4447]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "reorienttochild"}}, {"type": "dt", "indent": 4, "text": ["Vector To Child"], "extent": [4447, 4468], "body": [{"type": "para", "indent": 8, "text": ["The local space vector of the points' transforms that should point towards the given points child."], "extent": [4492, 4600]}], "container": true, "attrs": {"id": "ref_vector"}}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Visualize"], "extent": [4600, 4611], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Joint Axis Style"], "extent": [4611, 4633], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 8, "text": ["Set the style of the axis display.\n        Gnomon"], "extent": [4661, 4720], "body": [{"type": "para", "indent": 12, "text": ["A simple gnomon guide."], "extent": [4720, 4755]}], "container": true}, {"type": "dt", "indent": 8, "text": ["Hats"], "extent": [4755, 4769], "body": [{"type": "para", "indent": 12, "text": ["A flattened cone per-axis that may be more visible in many situations."], "extent": [4769, 4853]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "jointaxisstyle"}}, {"type": "dt", "indent": 4, "text": ["Show Parent to Child"], "extent": [4853, 4879], "body": [{"type": "para", "indent": 8, "text": ["Display a guide for each edge in the input geometry pointing from parent to child."], "extent": [4910, 5002]}], "container": true, "attrs": {"id": "showparenttochild"}}, {"type": "dt", "indent": 4, "text": ["Joint Scale"], "extent": [5002, 5019], "body": [{"type": "para", "indent": 8, "text": ["Set the scale of the guides."], "extent": [5043, 5081]}], "container": true, "attrs": {"id": "jointscale"}}], "container": true}], "container": true, "role": "item"}], "container": true, "role": "item_group"}], "text": "Parameters"}, {"level": 1, "id": "inputs", "container": true, "type": "inputs_section", "indent": 0, "role": "section", "extent": [5081, 5089], "body": [{"type": "para", "indent": 0, "text": ["The skeleton geometry whose topology has been modified upstream."], "extent": [5089, 5156]}], "text": "Inputs"}, {"level": 1, "id": "outputs", "container": true, "type": "outputs_section", "indent": 0, "role": "section", "extent": [5156, 5165], "body": [{"type": "para", "indent": 0, "text": ["A copy of the input skeleton with it\u2019s topology 'frozen'."], "extent": [5165, 5225]}], "text": "Outputs"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [5225, 5234], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/kinefx--skeleton", "type": "link", "text": "", "fullpath": "/nodes/sop/kinefx--skeleton"}], "extent": [5234, 5264]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/kinefx--deletejoints", "type": "link", "text": "", "fullpath": "/nodes/sop/kinefx--deletejoints"}], "extent": [5264, 5298]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/kinefx--visrig", "type": "link", "text": "", "fullpath": "/nodes/sop/kinefx--visrig"}], "extent": [5298, 5326]}], "container": true}], "text": "Related"}], "title": ["Rig Doctor"], "summary": ["Optimize and run checks on a SOP skeleton"]}