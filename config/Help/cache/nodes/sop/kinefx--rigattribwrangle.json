{"type": "root", "attrs": {"type": "node", "context": "sop", "namespace": "kinefx", "internal": "rigattribwrangle", "icon": "SOP/kinefx-rigattribwrangle", "tags": "attrs, vops, vex, tech, character, animation, retargeting, kinefx", "since": "18.5", "version": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Rig Attribute Wrangle"], "extent": [0, 26]}, {"type": "summary", "indent": 0, "text": ["Runs a VEX snippet to modify transform attribute values on a KineFX rig."], "extent": [222, 302]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [302, 317], "body": [{"type": "para", "indent": 0, "text": ["This node behaves in the same way as the ", {"scheme": "Icon", "value": "/icons/SOP/attribvop.svg", "type": "link", "text": "", "fullpath": "/icons/SOP/attribvop.svg"}, " ", {"scheme": "Node", "value": "/nodes/sop/attribwrangle", "type": "link", "text": ["Attribute Wrangle"], "fullpath": "/nodes/sop/attribwrangle"}, ", except it has a ", {"type": "ui", "text": ["Rig"]}, " tab in its parameters. The ", {"type": "ui", "text": ["Rig"]}, " tab exposes a custom viewport state and parameters to automatically recompute the point transforms for the inputs and output. This node corresponds to the ", {"scheme": "Node", "value": "/nodes/sop/attribvop", "type": "link", "text": ["Rig Attribute VOP SOP"], "fullpath": "/nodes/sop/attribvop"}, ", but uses a textual VEX snippet instead of a VOP network."], "extent": [317, 751]}, {"type": "para", "indent": 0, "text": ["This is a very powerful, low-level node that allows VEX experts to tweak attributes using code."], "extent": [751, 848]}, {"type": "para", "indent": 0, "text": ["This node runs the VEX snippet on the detail or every point/primitive/vertex (depending on the ", {"type": "ui", "text": ["Class"]}, " parameter) in the input geometry. The snippet can edit the input geometry by changing attributes. It can also access information from other geometry using attributes and VEX functions."], "extent": [848, 1139]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"keys": ["MMB"], "type": "keys", "text": null}, "-click on the node to see any error messages from the snippet."], "extent": [1139, 1212]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can use the VEX function ", {"type": "code", "text": ["ch"]}, " to evaluate parameters. The path is relative to this node and ", {"type": "code", "text": ["ch(\"parm\")"]}, " will evaluate the parameter ", {"type": "code", "text": ["parm"]}, " on this node. This evaluation will be done at the current time."], "extent": [1212, 1423]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Unlike the ", {"scheme": "Icon", "value": "/icons/SOP/attribcreate.svg", "type": "link", "text": "", "fullpath": "/icons/SOP/attribcreate.svg"}, " ", {"scheme": null, "value": "/nodes/sop/attribcreate", "type": "link", "text": ["Attribute Create SOP"], "fullpath": "/nodes/sop/attribcreate"}, " node, this node does ", {"type": "em", "text": ["not"]}, " use local variables. Also, all back-tick expressions and ", {"type": "code", "text": ["$F"]}, " variables will be evaluated at frame 1, ", {"type": "em", "text": ["not"]}, " the current time. Please use ", {"type": "code", "text": ["@Frame"]}, ", ", {"type": "code", "text": ["@Time"]}, ", or ", {"type": "code", "text": ["@TimeInc"]}, " instead."], "extent": [1423, 1726]}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Syntax"], "extent": [1726, 1739], "body": [{"type": "para", "indent": 0, "text": ["The ", {"type": "ui", "text": ["VEX snippet"]}, " parameter lets you enter a snippet of ", {"scheme": null, "value": "/vex/", "type": "link", "text": ["VEX code"], "fullpath": "/vex/index"}, " to run on the input geometry.\nSee ", {"scheme": null, "value": "/vex/snippets", "type": "link", "text": ["VEX snippets"], "fullpath": "/vex/snippets"}, " for basic information on the syntax available in the snippet parameter.\nSee ", {"scheme": null, "value": "/vex/", "type": "link", "text": ["the VEX chapter"], "fullpath": "/vex/index"}, " for general information on the VEX language."], "extent": [16, 299]}]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [1767, 1779], "body": [{"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Code"], "extent": [1779, 1791], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Group"], "extent": [1791, 1799], "body": [{"type": "para", "indent": 4, "text": ["Specifies a subset of points for the input geometry to run the program on. Leave this parameter field blank to affect all points in the input."], "extent": [1814, 1962]}], "container": true, "attrs": {"id": "group"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Group Type"], "extent": [1962, 1974], "body": [{"type": "para", "indent": 4, "text": ["Specifies what the group is made of."], "extent": [1994, 2036]}], "container": true, "attrs": {"id": "group_type"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Run Over"], "extent": [16, 26], "body": [{"type": "para", "indent": 4, "text": ["Apply the VEX code to each component of this type (points, primitives/faces, or vertices. Or choose ", {"type": "ui", "text": ["Detail"]}, " to run the code only once. For each component, the code runs with attributes bound to variables starting with ", {"type": "code", "text": ["@"]}, " (for example ", {"type": "code", "text": ["@Cd"]}, ") for reading and writing."], "extent": [42, 317]}, {"type": "para", "indent": 4, "text": ["If you choose ", {"type": "code", "text": ["Numbers"]}, ", Houdini runs the code for certain number of iterations instead of over components. In this mode the code only has read-only detail-level attributes bound to ", {"type": "code", "text": ["@"]}, " variables."], "extent": [317, 519]}], "container": true, "attrs": {"id": "class"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Number Count"], "extent": [519, 533], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Run Over"]}, " is ", {"type": "ui", "text": ["Numbers"]}, ", the number of iterations to run the code. In each iteration, ", {"type": "code", "text": ["@numelem"]}, " is bound to this total count, and ", {"type": "code", "text": ["@elemnum"]}, " is bound to the iteration number, from ", {"type": "code", "text": ["0"]}, " to ", {"type": "code", "text": ["@numelem - 1"]}, ". "], "extent": [556, 775]}, {"type": "para", "indent": 4, "text": ["In this mode the code only has read-only detail-level attributes bound to ", {"type": "code", "text": ["@"]}, " variables."], "extent": [775, 869]}], "container": true, "attrs": {"id": "vex_numcount"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Thread Job Size"], "extent": [869, 886], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Run Over"]}, " is ", {"type": "ui", "text": ["Numbers"]}, ", this is the number of iterations to run per separate thread. If this number is greater than or equal the ", {"type": "ui", "text": ["Number count"]}, ", all iterations will run serially in a single thread. If this is ", {"type": "code", "text": ["1"]}, ", each iteration will run in a separate thread. In between, the node will group the iterations into batches of this size, and run each batch in parallel on separate threads."], "extent": [914, 1316]}], "container": true, "attrs": {"id": "vex_threadjobsize"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["VEXpression"], "extent": [2337, 2350], "body": [{"type": "para", "indent": 4, "text": ["A snippet of VEX code that will manipulate the point attributes.\n    You can use ", {"type": "code", "text": ["@", {"type": "var", "text": ["variable_name"]}]}, " syntax to access geometry attributes."], "extent": [2368, 2513]}], "container": true, "attrs": {"id": "snippet"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Attributes to Create"], "extent": [2089, 2111], "body": [{"type": "para", "indent": 4, "text": ["Specifies a list of allowed names. Attributes are only created if their names match this pattern. The default ", {"type": "code", "text": ["*"]}, " pattern allows any attribute to be created. Bound attributes, such as ", {"type": "code", "text": ["vtxnum"]}, ", cannot be created and will be ignored."], "extent": [2111, 2349]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Enforce Prototypes"], "extent": [16, 36], "body": [{"type": "para", "indent": 4, "text": ["Requires that you declare ", {"type": "code", "text": ["@"]}, " bindings in snippets as prototypes before using them. This applies to both attributes (for example ", {"type": "code", "text": ["@Cd"]}, ") and ", {"type": "q", "text": ["convenience"]}, " bindings such as ", {"type": "code", "text": ["@ptnum"]}, " and ", {"type": "code", "text": ["@Frame"]}, ". For example:"], "extent": [36, 248]}, {"lang": "vex", "type": "pre", "indent": 4, "text": ["\n    // Declare bindings\n    int @ptnum;\n    float @Frame;\n    vector @Cd;\n\n    // Use bindings after declaration\n    int pointnum = @ptnum;\n    float red = @Cd[0] / @Frame;\n    "], "extent": [248, 447]}, {"type": "para", "indent": 4, "text": ["Automatic binding with the ", {"type": "code", "text": ["@"]}, " syntax can be convenient, but as your scene becomes more complex there is the risk that a typo in an ", {"type": "code", "text": ["@"]}, " binding will silently just bind a non-existent attribute."], "extent": [447, 646]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Bindings"], "extent": [2385, 2400], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Autobind by Name"], "extent": [2400, 2419], "body": [{"type": "para", "indent": 4, "text": ["When on, attributes are automatically bound to parameters by name. If for some reason you need CVEX parameters to have different names than the corresponding attributes, turn off this parameter and use the ", {"type": "ui", "text": ["Number of Bindings"]}, " multiparm to set up mappings between ", {"type": "ui", "text": ["Attribute Name"]}, " and ", {"type": "ui", "text": ["VEX Parameter"]}, "."], "extent": [2419, 2732]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Number of Bindings"], "extent": [2732, 2752], "body": [{"type": "para", "indent": 4, "text": ["Multiparm that lets you manually specify the bindings of each name by setting up mappings between ", {"type": "ui", "text": ["Attribute Name"]}, " and ", {"type": "ui", "text": ["VEX Parameter"]}, ". Integer attributes will bind to integer parameters. Float attributes will bind to float, vector, point, matrix, or matrix4 depending on their tuple size. String attributes will bind to strings."], "extent": [2752, 3091]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Attribute Name"], "extent": [3091, 3111], "body": [{"type": "para", "indent": 8, "text": ["Name of the attribute to bind to the specified ", {"type": "ui", "text": ["VEX Parameter"]}, "."], "extent": [3111, 3186]}], "container": true}, {"type": "dt", "indent": 4, "text": ["VEX Parameter"], "extent": [3186, 3205], "body": [{"type": "para", "indent": 8, "text": ["Name of the parameter to bind to the specified ", {"type": "ui", "text": ["Attribute Name"]}, "."], "extent": [3205, 3281]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Autobind Groups by Name"], "extent": [3281, 3306], "body": [{"type": "para", "indent": 4, "text": ["When on, automatically binds any groups to the integer parameter prefixed with ", {"type": "code", "text": ["group_"]}, ". If for some reason you need CVEX parameters to have different names than the corresponding groups, turn this off and use the ", {"type": "ui", "text": ["Group Bindings"]}, " multiparm to set up mappings between ", {"type": "ui", "text": ["Group Name"]}, " and ", {"type": "ui", "text": ["VEX Parameter"]}, "."], "extent": [3306, 3623]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Group Bindings"], "extent": [3623, 3639], "body": [{"type": "para", "indent": 4, "text": ["Multiparm that lets you manually specify the bindings of each group by setting up the mappings between ", {"type": "ui", "text": ["Group Name"]}, " and ", {"type": "ui", "text": ["VEX Parameter"]}, "."], "extent": [3639, 3785]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Group Name"], "extent": [3785, 3801], "body": [{"type": "para", "indent": 8, "text": ["Name of the group to bind to the specified ", {"type": "ui", "text": ["VEX Parameter"]}, "."], "extent": [3801, 3872]}], "container": true}, {"type": "dt", "indent": 4, "text": ["VEX Parameter"], "extent": [3872, 3891], "body": [{"type": "para", "indent": 8, "text": ["Name of the parameter to bind to the specified ", {"type": "ui", "text": ["Group Name"]}, "."], "extent": [3891, 3963]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Evaluation Node Path"], "extent": [3963, 3985], "body": [{"type": "para", "indent": 4, "text": ["VEX functions like ", {"type": "code", "text": ["ch()"]}, " usually evaluate with respect to this node. This parameter lets you specify a node path to override where the path search starts from. This is useful for embedding in a digital asset, where you want searches to start from the asset root."], "extent": [3985, 4254]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Export Parameters"], "extent": [4254, 4273], "body": [{"type": "para", "indent": 4, "text": ["When a VEX parameter is exported, the bound attribute will be created if one doesn\u2019t exist. This parameter lets you specify a pattern that can be used to override the export option on the VEX shader to avoid writing to or creating certain attributes. When the pattern matches the VEX parameter, ", {"type": "em", "text": ["not"]}, " the bound attribute, the attribute will still be bound for reading."], "extent": [4273, 4647]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Update Normals If Displaced"], "extent": [4647, 4676], "body": [{"type": "para", "indent": 4, "text": ["If points are being run over and the ", {"type": "code", "text": ["P"]}, " attribute is written to, but the ", {"type": "code", "text": ["N"]}, " attribute is not written to, then any incoming normals will become out-of-date. When this parameter is on, vertex and point normals will be updated when this occurs."], "extent": [4676, 4925]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Attribute To Match"], "extent": [4925, 4945], "body": [{"type": "para", "indent": 4, "text": ["Specifies the attribute to use for matching. This attribute must be present on both inputs for matching to occur.  Otherwise, matching is done by element number (for example, point number when running over points). The attribute should be either an integer or string attribute. This controls how the ", {"type": "code", "text": ["opinput#_"]}, " virtual bindings connect. For example, you can use ", {"type": "code", "text": ["v@opinput1_Cd"]}, " to read the second input\u2019s ", {"type": "code", "text": ["v@Cd"]}, " attribute."], "extent": [4945, 5374]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Compute Results In Place"], "extent": [5374, 5400], "body": [{"type": "para", "indent": 4, "text": ["When on, the Rig Attribute Wrangle node is able to work on the incoming geometry in place without making a copy of it.  This can speed up processing as one less copy is made, but requires that the VEX code doesn\u2019t bind for writing any attributes that are read from the first input."], "extent": [5400, 5687]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Output Selection Group"], "extent": [5687, 5711], "body": [{"type": "para", "indent": 4, "text": ["Specifies the name of a group to use as the output selection. When the Highlight flag is enabled for the Rig Attribute Wrangle node, this group will be the output selection used by downstream modeling tools (if they exist)."], "extent": [5711, 5940]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["VEX Precision"], "extent": [2846, 2862], "body": [{"type": "para", "indent": 4, "text": ["VEX can evaluate at 32-bit or 64-bit precision.  64-bit provides\n    higher accuracy, especially for transforms."], "extent": [2886, 3008]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [3008, 3018], "body": [{"type": "para", "indent": 8, "text": ["Incoming attributes will preserve their original precision, so using 64-bit VEX on 32-bit positions will convert them to 64-bit, apply the operation, then convert back to 32-bit when writing out."], "extent": [3018, 3227]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 4, "text": ["The auto mode will switch between 32-bit and 64-bit depending on the preferred precision of the incoming geometry. When run in 64-bit precision, any created attributes will be 64-bit. When run in 32-bit any created attributes will be 32-bit. Use ", {"scheme": "Node", "value": "/nodes/sop/attribcast", "type": "link", "text": "", "fullpath": "/nodes/sop/attribcast"}, " to change the preferred precision."], "extent": [3227, 3535]}], "container": true, "attrs": {"id": "vex_precision"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Rig"], "extent": [5986, 5996], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Viewport State"], "extent": [5996, 6013], "body": [{"type": "para", "indent": 4, "text": ["Specifies a string pointing to a valid viewport state name."], "extent": [6034, 6099]}], "container": true, "attrs": {"id": "viewerstate"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Compute Transforms for Output"], "extent": [6099, 6130], "body": [{"type": "para", "indent": 4, "text": ["When on, computes the transforms for the output. Gives you the same behavior as adding a ", {"scheme": "Icon", "value": "/icons/SOP/kinefx-computetransform.svg", "type": "link", "text": "", "fullpath": "/icons/SOP/kinefx-computetransform.svg"}, " ", {"scheme": null, "value": "/nodes/sop/kinefx--computetransform", "type": "link", "text": ["Compute Transform SOP"], "fullpath": "/nodes/sop/kinefx--computetransform"}, " node after the output."], "extent": [6147, 6370]}], "container": true, "attrs": {"id": "compute"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Compute Transforms for Input 1"], "extent": [6370, 6402], "body": [{"type": "para", "indent": 4, "text": ["When on, computes the transforms for Input 1. Gives you the same behavior as adding a ", {"scheme": "Icon", "value": "/icons/SOP/kinefx-computetransform.svg", "type": "link", "text": "", "fullpath": "/icons/SOP/kinefx-computetransform.svg"}, " ", {"scheme": null, "value": "/nodes/sop/kinefx--computetransform", "type": "link", "text": ["Compute Transform SOP"], "fullpath": "/nodes/sop/kinefx--computetransform"}, " before the input."], "extent": [6420, 6635]}], "container": true, "attrs": {"id": "compute1"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Compute Transforms for Input 2"], "extent": [6635, 6667], "body": [{"type": "para", "indent": 4, "text": ["When on, computes the transforms for Input 2. Gives you the same behavior as adding a ", {"scheme": "Icon", "value": "/icons/SOP/kinefx-computetransform.svg", "type": "link", "text": "", "fullpath": "/icons/SOP/kinefx-computetransform.svg"}, " ", {"scheme": null, "value": "/nodes/sop/kinefx--computetransform", "type": "link", "text": ["Compute Transform SOP"], "fullpath": "/nodes/sop/kinefx--computetransform"}, " before the input."], "extent": [6685, 6900]}], "container": true, "attrs": {"id": "compute2"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Compute Transforms for Input 3"], "extent": [6900, 6932], "body": [{"type": "para", "indent": 4, "text": ["When on, computes the transforms for Input 3. Gives you the same behavior as adding a ", {"scheme": "Icon", "value": "/icons/SOP/kinefx-computetransform.svg", "type": "link", "text": "", "fullpath": "/icons/SOP/kinefx-computetransform.svg"}, " ", {"scheme": null, "value": "/nodes/sop/kinefx--computetransform", "type": "link", "text": ["Compute Transform SOP"], "fullpath": "/nodes/sop/kinefx--computetransform"}, " before the input."], "extent": [6950, 7165]}], "container": true, "attrs": {"id": "compute3"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Compute Transforms for Input 4"], "extent": [7165, 7197], "body": [{"type": "para", "indent": 4, "text": ["When on, computes the transforms for Input 4. Gives you the same behavior as adding a ", {"scheme": "Icon", "value": "/icons/SOP/kinefx-computetransform.svg", "type": "link", "text": "", "fullpath": "/icons/SOP/kinefx-computetransform.svg"}, " ", {"scheme": null, "value": "/nodes/sop/kinefx--computetransform", "type": "link", "text": ["Compute Transform SOP"], "fullpath": "/nodes/sop/kinefx--computetransform"}, " before the input."], "extent": [7215, 7430]}], "container": true, "attrs": {"id": "compute4"}, "role": "item"}], "container": true, "role": "item_group"}]}], "text": "Parameters"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [7430, 7439], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/attribvop", "type": "link", "text": "", "fullpath": "/nodes/sop/attribvop"}], "extent": [7439, 7462]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/attribwrangle", "type": "link", "text": "", "fullpath": "/nodes/sop/attribwrangle"}], "extent": [7462, 7489]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/kinefx--computetransform", "type": "link", "text": "", "fullpath": "/nodes/sop/kinefx--computetransform"}], "extent": [7489, 7527]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/kinefx--rigattribvop", "type": "link", "text": "", "fullpath": "/nodes/sop/kinefx--rigattribvop"}], "extent": [7527, 7561]}], "container": true}], "text": "Related"}], "title": ["Rig Attribute Wrangle"], "summary": ["Runs a VEX snippet to modify transform attribute values on a KineFX rig."], "included": ["/nodes/sop/_run_over", "/nodes/sop/attribvop", "/nodes/sop/pointwrangle", "/nodes/sop/wrangle_syntax", "/vex/_enforce_prototypes"]}